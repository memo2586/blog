<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gmaes101-Lecture_09_Shading_3</title>
    <link href="/2023/12/08/Gmaes101-Lecture-09-Shading-3/"/>
    <url>/2023/12/08/Gmaes101-Lecture-09-Shading-3/</url>
    
    <content type="html"><![CDATA[<h1 id="shading-3">Shading 3</h1><h3 id="barycentric-coordinates">1. Barycentric Coordinates</h3><ul><li><p><strong>为什么要使用重心坐标在三角形内部进行插值？</strong></p><p>我们在前面所学的内容中，很多操作都是在三角形的顶点上计算完成的，同时，我们又希望这些操作能在三角形内部有一个平滑的过度。为此，我们需要使用重心坐标进行插值。</p></li><li><p><strong>对什么进行中心插值？</strong></p><p>插值的内容可以有很多，例如三角形内部的纹理、深度、逐顶点的颜色与法线、Phongshading 逐像素的法线等 ......</p><p>可以说，三角形上的任何一种属性几乎都可以使用插值计算。</p></li><li><p><strong>如何使用重心坐标进行插值？</strong></p><p><img src="Snipaste_2023-12-08_14-48-02.png" style="zoom:33%;" /></p><p>三角形上的任意一个点 <spanclass="math inline">\((x,y)\)</span>，都可以用三个顶点的坐标的线性组合表示，并且满足线性组合的系数大于0且和为1，即满足：<span class="math display">\[\begin{align*}&amp; (x,y) = \alpha A+\beta B+\gamma C \\&amp; \alpha&gt;0,\beta&gt;0,\gamma&gt;0 \\&amp; \alpha+\beta+\gamma=1 \\\end{align*}\]</span>也就是说，我们描述三角形内的一个点的位置时，只要给定三角形三个顶点的坐标，就可以利用这三个坐标的线性组合，描述出这个点的位置在重心坐标下的表示。</p></li><li><p><strong>如何计算重心坐标？</strong></p><p><img src="Snipaste_2023-12-08_15-03-02.png" style="zoom:33%;" /></p><p>任意点的重心坐标是可以通过面积的比计算得到的。</p><p>如上图，三角形三个顶点的系数分别是该顶点所对三角形的面积占总面积的比值，即：<span class="math display">\[\begin{gather*}\alpha = \frac{A_A}{A_A+A_B+A_C} \\\beta = \frac{A_B}{A_A+A_B+A_C} \\\gamma = \frac{A_C}{A_A+A_B+A_C}\end{gather*}\]</span> 使用坐标简化计算，可得： <span class="math display">\[\begin{align*}&amp; \alpha =\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\\&amp; \\&amp; \beta =\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}   \\&amp; \\&amp; \gamma = 1 - \alpha - \beta\end{align*}\]</span></p></li><li><p><strong>如何使用重心坐标进行插值？</strong></p><p><img src="Snipaste_2023-12-08_15-25-22.png" style="zoom: 33%;" /></p><p>与重心坐标相同，三角形内部任意一个点的属性也是可以通过三角形三个顶点的属性经过线性组合得到的。因此，我们可以直接使用该点重心坐标的系数，计算该点的插值。</p></li><li><p><strong>在投影变换下无法保证重心坐标不变</strong></p><p>在三维空间中的一些属性，经过投影变换到二维之后再进行重心坐标插值是无法保证其正确性的，这一点体现在深度的插值上。</p><p>如何解决这个问题呢？我们插值计算一个点的深度时，应该先使用逆变换回到三维空间中进行插值计算，再将计算结果返回。</p></li></ul><hr /><h3 id="applying-textures">2. Applying Textures</h3><ul><li><p><strong>如何将纹理应用到实时渲染中？</strong></p><p>在我们学习了重心坐标后，我们可以使用插值算出三角形内部任意一个点的纹理图坐标(u,v)，接着在纹理图中查找对应坐标的属性值。可以简单地描述为一下过程：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">for each rasterized screen sample (x, y):<br>  (u, v) = evaluate texture coordinate at (x, y);<br>  textcolor = texture.sample(u, v);<br>  set sample&#x27;s color to texcolor;<br></code></pre></td></tr></table></figure></li><li><p><strong>应用纹理图时遇到的问题</strong></p><p>屏幕的像素是 pixel ，纹理图的像素被称为 texel（纹素）。</p><ul><li><p>Texture Magnification（纹理的放大）</p><p><img src="Snipaste_2023-12-08_16-01-39.png" style="zoom:38%;" /></p><p>当一个模型太大，它映射到屏幕上的像素多于纹理图的 texel时，会出现三角形顶点坐标映射到纹理图上时不是一个整数。为了正常进行纹理映射，我们对它进行近似到最近的一个整数值。但这么做会导致这个点包括它周围许多点都会映射到纹理图上的同一个坐标。</p><p>为了解决这个问题，我们应该找到一种别的办法，能够在查询非整数坐标时得到一个更加正确的值使其能够平滑地过渡。</p><ul><li><p><strong>Bilinear interpolation</strong>（双线性插值）</p><p><img src="Snipaste_2023-12-08_16-49-30.png" style="zoom:75%;" /></p><p>假设有一个点映射到纹理图上的红点处，我们可以找出它临近的四个texel，并且定义其分别在水平方向上与texel的距离为<span class="math inline">\(s\)</span> 与垂直方向上的距离为 <spanclass="math inline">\(t\)</span>，再定义一个线性插值操作如下： <spanclass="math display">\[lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\]</span> 那么双线性插值如何操作呢？首先我们使用水平方向上的距离 <spanclass="math inline">\(s\)</span>对水平方向上的四个顶点进行线性插值：</p><p><img src="Snipaste_2023-12-08_17-01-38.png" style="zoom:75%;" /><span class="math display">\[\begin{align*}&amp; u_0=lerp(s,u_{00},u_{10}) \\&amp; u_1=lerp(s,u_{01},u_{11})\end{align*}\]</span> 再使用垂直方向上的距离 <span class="math inline">\(t\)</span>对 <span class="math inline">\(u_0\)</span> 与 <spanclass="math inline">\(u_1\)</span> 进行插值： <spanclass="math display">\[f(x,y)=lerp(t,u_0,u_1)\]</span>这样计算得到的插值就会综合周围四个texel的数值，也就可以比较平滑地过渡了。</p></li><li><p>Bicubic</p><p>使用周围地16个texel进行较为复杂地三次插值，插值的效果更好。</p></li></ul></li><li><p>Texture Magnification</p><p><img src="Snipaste_2023-12-08_17-16-13.png" style="zoom: 50%;" /></p><p>图中对远处的模型进行简单地纹理映射后出现了摩尔纹而近处出现了锯齿，为什么？这是因为远处的模型太小而<strong>纹理图太大导致的走样</strong>。</p><p><img src="Snipaste_2023-12-08_17-20-29.png" style="zoom:75%;" /></p><p>模型距离越远，每一个像素覆盖到的texel越多。当一个像素覆盖了多个texel，如果我们认为这个像素的值是它所覆盖的texel的平均值，这显然是不对的。在信号上可以理解为使用了一个采样点，去采样一个连续变化的信号（高频信号），这显然会引起走样问题。</p><p>那我们能否使用类似于MSAA的超采样算法解决这个问题呢？答案是可以的，但是会产生大量的开销。解决这个问题，我们还有更好的办法，那就是避免采样，直接做<strong>预处理</strong>，使我们可以直接知道某个范围内的平均值是多少。这样一来，问题就从一个点查询问题变成了一个范围查询问题。</p><ul><li><p><strong>Mipmap</strong></p><p>​ <strong>Mipmap能在方形区域内做快速的近似查询</strong></p><p><img src="Snipaste_2023-12-08_17-38-16.png" style="zoom:75%;" /></p><p>Mipmap从原始图生成许多低分辨率的纹理图，每一层减少一半的像素，原始像素为<span class="math inline">\(n\times n\)</span> 的纹理图最多会由 <spanclass="math inline">\(\log{n}\)</span> 层。为了存储这些层，会产生额外<span class="math inline">\(\frac{1}{3}\)</span> 的存储开销。</p><p><img src="Snipaste_2023-12-08_17-55-46.png" style="zoom:75%;" /></p><p>我们要在Mipmap中查询某个像素覆盖区域的平均值，那么我们应该先求出近似像素所覆盖的纹理图区域的方形边长是多少。假设我们有这么一个像素点，我们取它相邻两个像素，并将它们都投影到纹理图坐标系上。</p><p><img src="Snipaste_2023-12-08_18-03-17.png" style="zoom:75%;" /></p><p>接着，我们计算这个像素点与相邻的两个坐标在纹理图坐标系上的距离分别是多少再取最大值，就可以近似出像素所覆盖的纹理图区域的方形边长是多少了。简单地说，我们做了一个将像素坐标上两个长度为1个单位的距离映射到纹理图坐标系中，并计算它们在纹理坐标系中长度应该是多少的操作。</p><p>那如何在Mipmap上查询边长为 L 的方形？很简单，如果 L等于1，那么我可以直接从原始图上找。那如果 L 等于 4 ？很显然，一个 4x4的texel会在第二层被Mipmap合并为一个texel。也就是说，对于一个 LxL的方形，他会在第 <span class="math inline">\(\log_2{L}\)</span>层被合并。</p><p>那么纹理坐标系中长度的计算方法是： <span class="math display">\[\begin{align*}&amp; D = \log_2{L} \\&amp; L = \max\left(\sqrt{ {(\frac{du}{dx})}^2+{(\frac{dv}{dx})}^2},\sqrt{{(\frac{du}{dy})}^2+{(\frac{dv}{dy})}^2}\right)\end{align*}\]</span>到目前为止，我们可以发现这些操作会产生一定的渐变效果，但是不连续。因为查询结果在不同层上的话就会破环连续性。</p><p><img src="Snipaste_2023-12-08_18-37-28.png" /></p></li><li><p><strong>Trilinear Interpolation</strong>（三线性插值）</p><p><img src="Snipaste_2023-12-08_18-40-37.png" style="zoom:75%;" /></p><p>为了解决 Mipmap在层与层之间不连续的问题，我们需要在层间再做一次插值运算。也就是当一个像素投影到一个非整数边长的方形上时，我们在这个边长的相邻两层先分别做一次双线性插值，然后使用双线性插值的结果与这个非整数边长再做一次层与层之间的插值，近似地得到一个非整数层的结果。</p><p><img src="Snipaste_2023-12-08_19-26-29.png" style="zoom:75%;" /></p></li><li><p>Mipmap会出现Overblur</p><p><img src="Snipaste_2023-12-08_19-28-22.png" style="zoom:75%;" /></p><p>为什么会出现overblur？Mipmap受限于只能近似得到方形区域的平均值，那如果像素的纹理覆盖区域不是方形呢？这会导致Mipmap近似出来的值与实际的值大相径庭。为了解决这个问题，我们需要新的预处理方法。</p></li><li><p>Anisotropic Filtering（各向异性过滤）</p><p><img src="Snipaste_2023-12-08_19-33-43.png" /></p><p>各向异性过滤在水平与竖直的两个方向上压缩原始图片，也就是说它可以快速查找到矩形覆盖区域的值。它会在原始图像的基础上多出3倍的存储开销。（显存够大就随便开）</p><p><img src="Snipaste_2023-12-08_19-36-11.png" /></p><p>各向异性过滤可以部分问题，但依旧不是完美的。</p></li><li><p>EWA Filtering（EWA过滤）</p><p><img src="Snipaste_2023-12-08_19-38-59.png" /></p><p>EWA过滤将任意一个不规则的覆盖区域拆解成许多个圆形的组合，通过<strong>多次查询</strong>这些圆形来得到覆盖区域的平均值。但EWA在时间上的开销明显要比Mipmap与各向异性过滤大了。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture08 Shading 2</title>
    <link href="/2023/12/08/Games101-Lecture-08-Shading-2/"/>
    <url>/2023/12/08/Games101-Lecture-08-Shading-2/</url>
    
    <content type="html"><![CDATA[<h1 id="shading-2">Shading 2</h1><h3 id="shading-frequencies">1. Shading Frequencies</h3><ul><li><p><strong>不同着色频率的着色方法</strong></p><p><img src="Snipaste_2023-12-07_11-22-42.png" style="zoom: 33%;" /></p><p>​ 上图三种着色频率不同的着色方法分别是flat shading、Gouraud shading 与Phong shading；</p><ul><li><p>flat shading</p><p>​对每一个三角形求出其法线方向，根据法线、光照等得出三角形内部的一种着色方案并应用到整个三角形所覆盖的像素上，三角形内部的着色不会有任何变化。很明显flatshading的效果并不好。</p></li><li><p>Gouraud shading</p><p>​在任意一个顶点上，求出顶点的法线方向然后对顶点做一次着色。得出三角形三个顶点的着色后，利用插值将三角形内部覆盖的像素的着色计算出来。</p></li><li><p>Phong shading</p><p>​求出三角形三个顶点的法线方向后，对三角形所覆盖的每一个像素使用插值计算出它的法线方向，在对这个像素进行着色。</p></li></ul><p><img src="Snipaste_2023-12-07_17-18-15.png" style="zoom: 67%;" /></p><p>​ 当模型内三角形的数量接近像素的数量时，可以看出flatshading的效果也并不差。也就是说，着色频率本身也取决于模型内点或面出现的频率，当模型面数很高的情况下，不必要使用复杂的方式。但是在模型足够复杂的情况下，flatshading并不一定比其他模型快。</p></li><li><p><strong>如何计算顶点的法线？</strong></p><p><img src="Snipaste_2023-12-07_17-45-57.png" style="zoom:75%;" /></p><p>​一个简单的办法：一个顶点必定会是相邻多个三角形共同的顶点，那我们认为该顶点的法线就是相邻三角形的法线和求加权平均，权重可以是三角形的面积。</p></li><li><p><strong>如何计算逐像素的法线？</strong></p><p>​假设已经求出三角形顶点的法线，使用重心坐标计算出逐像素的法线（后面讲）。</p></li></ul><hr /><h3 id="graphics-real-time-rendering-pipeline">2. Graphics (Real-timeRendering) Pipeline</h3><ul><li><p><strong>什么是实时渲染管线?</strong></p><p><img src="Snipaste_2023-12-07_20-30-04.png" style="zoom:67%;" /></p><p>​从场景到最后的一张图片中间经历的过程就是实时渲染管线(前面学过的所有过程)，他一般是被显卡等硬件定义好的，显卡会提供可编程的接口，可以自定义如何去着色。</p><p>​决定如何运作将这些顶点或像素着色的代码称为shader（着色器）。</p></li><li><p><strong>Shader Programs</strong></p><p>根据着色器的着色方法不同，可以将其分为 vertex shader 或 fragmentshader 等。</p><p>一个 openGL 的 GLSL fragment shader 示例程序：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl">unifrom <span class="hljs-type">sampler2D</span> myTexture;<br>unifrom <span class="hljs-type">vec3</span> lightDir;<br><span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> norm;<br><br><span class="hljs-type">void</span> diffuseShader()&#123;<br><span class="hljs-type">vec3</span> kd;<br>kd = texture2d(myTexture, uv);<span class="hljs-comment">//纹理</span><br>kd *= <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">dot</span>(-lightDir, norm), <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<span class="hljs-comment">//简化的Phong模型</span><br><span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(kd, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr /><h3 id="texture-mapping">3. Texture Mapping</h3><ul><li><p><strong>什么是纹理映射？</strong></p><p><img src="Snipaste_2023-12-07_23-37-12.png" style="zoom:75%;" /></p><p>​图中如何物体显示出不同的颜色？他们的基本区别是共用一个着色模型，但它们本身的漫反射模型系数发生了改变。为此我们希望有一种方法能够定义一个物体上的任何一个点它的属性。</p><p>​ <img src="Snipaste_2023-12-07_23-41-13.png" /></p><p>​任何一个三维物体的表面都可以定义为一个二维的图。我们将物体表面任何一个点的属性映射到一张图中。反过来说，如果我们有一张纹理图，我们就可以定义一个物体上的任何一个点它的属性。</p><p><img src="Snipaste_2023-12-07_23-44-05.png" /></p><p>为此，我们需要在纹理上定义一个坐标系。通常来说会定义 u 与 v两个坐标方向，并且都在 [0,1] 之间。</p><p><img src="Snipaste_2023-12-07_23-50-38.png" style="zoom:67%;" /></p><p>有些纹理图可以被不断复制且四个方向都可以无缝衔接，这种纹理图被称为tiled textures 。</p><p><img src="Snipaste_2023-12-07_23-57-38.png" /></p><p>知道了每一个顶点对应的纹理图坐标后，我们如何知道三角形内部像素的属性呢？下节插值算法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture07 Shading 1</title>
    <link href="/2023/12/07/Games101-Lecture-07-Shading-1/"/>
    <url>/2023/12/07/Games101-Lecture-07-Shading-1/</url>
    
    <content type="html"><![CDATA[<h1 id="shading">Shading</h1><h3 id="visibility">1. Visibility</h3><ul><li><p><strong>画家算法</strong></p><p>非常简单，就是从远到近绘制三角形。但是缺陷也很明显，三个三角形两两之间都存在覆盖关系时，画家算法就不能绘制正确的图形了。</p><p><img src="Snipaste_2023-12-05_14-40-36.png" style="zoom: 50%;" /></p></li><li><p><strong>Z-buffering</strong></p><p>维护每个像素上深度最小的样本颜色，算法完成后会生成一副图存储深度信息与另一幅图存储目标图像。</p><ul><li>伪代码：</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">each</span> Triangle T)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">each</span> sample (x,y,z) <span class="hljs-keyword">in</span> T)&#123;<br><span class="hljs-keyword">if</span>(z &lt; zbuffer[x,y])&#123;<span class="hljs-comment">//找出目前最近的样本</span><br>framebuffer[x,y] = rgb;<span class="hljs-comment">//更新颜色</span><br>zbuffer[x,y] = z;<span class="hljs-comment">//更新深度</span><br>&#125;<br><span class="hljs-keyword">else</span><br>;<span class="hljs-comment">//什么都不做</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="Snipaste_2023-12-05_14-57-31.png" style="zoom:50%;" /></p><ul><li>时间复杂度为O(n)</li></ul></li></ul><hr /><h3 id="shading-1">2. Shading</h3><ul><li><p><strong>什么是着色？</strong></p><p>对不同的物体应用不同材质的过程。</p></li><li><p><strong>基础的着色模型——Blnn-Phong 反射模型（Blnn-PhongReflectance Model）</strong></p><p>一般来说，我们看一个物体的光照大致可以分成三部分：高光（Specularhighlights）、漫反射（Diffuse reflection）、环境光（Ambientlighting）。</p><p><img src="Snipaste_2023-12-05_15-08-34.png" style="zoom:50%;" /></p><ul><li><p>inputs：</p><p><img src="Snipaste_2023-12-05_15-11-14.png" style="zoom:50%;" /></p><p>假设在每一个极小的点（shading point）上都是平面，在此平面上定义：</p><ul><li>观察方向：从shading point到相机的方向向量 <spanclass="math inline">\(\overrightarrow{v}\)</span> ；</li><li>法向量：垂直于shading point所在平面的方向法向量 <spanclass="math inline">\(\overrightarrow{n}\)</span> ；</li><li>光照方向：从shading point到光源的方向向量 <spanclass="math inline">\(\overrightarrow{l}\)</span> ；</li><li>表面材质：颜色、光泽 . . .</li></ul></li><li><p>漫反射（Diffuse reflection）</p><p><img src="Snipaste_2023-12-05_15-21-20.png" style="zoom:50%;" /></p><p>一个物体表面的法线 <spanclass="math inline">\(\overrightarrow{n}\)</span> 与光照方向 <spanclass="math inline">\(\overrightarrow{l}\)</span> 的夹角 <spanclass="math inline">\(\theta\)</span> 决定了该物体表面的亮度。</p><p>夹角 <span class="math inline">\(\theta\)</span>决定了该平面能够接收到光照的面积，shadingpoint周围单位面积所能接收到的能量为 <spanclass="math inline">\(\overrightarrow{n}\cdot\overrightarrow{l}\)</span>。</p><p><img src="Snipaste_2023-12-05_15-29-38.png" style="zoom: 33%;" /></p><p>我们认为，如果一个点光源在任意时刻向任意方向发出相同的能量，那么这些能量一定集中在一个所谓的球壳上，且每个球壳上的能量总和都是相等的。当球壳与点光源的距离越远，球壳的面积越大，所以球壳上单位面积所蕴含的能量就越小。</p><p>假设距离点光源单位距离的球壳上单位面积光照强度为 <spanclass="math inline">\(I\)</span>，则距离 <spanclass="math inline">\(r\)</span> 的球壳上单位面积光照强度为 <spanclass="math inline">\(I/r^2\)</span> 。</p><p>由以上两点，我们可以知道shading point接收到漫反射的能量为： <spanclass="math display">\[L_d=k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})\]</span> 其中 <span class="math inline">\(K_d\)</span> 由shadingpoint的材质决定：</p><p><img src="Snipaste_2023-12-05_15-43-18.png" style="zoom:50%;" /></p><p>漫反射与观察方向 <spanclass="math inline">\(\overrightarrow{v}\)</span>没有任何关系。</p></li><li><p>高光（Specular highlights）</p><p><img src="Snipaste_2023-12-05_16-00-09.png" style="zoom:50%;" /></p><p>什么时候会看到高光呢？简单的说，如果一个物体足够光滑，那么高光会在光线的出射方向附近有一定范围的分布，当观察方向在这个分布范围内时，可以观察到高光。</p><p><img src="Snipaste_2023-12-07_09-57-42.png" style="zoom: 50%;" /></p><p>我们可以观察到，当观察方向 <spanclass="math inline">\(\overrightarrow{v}\)</span>与光线的出射方向接近时，说明半程向量 <spanclass="math inline">\(\overrightarrow{h}\)</span> 和 法线方向 <spanclass="math inline">\(\overrightarrow{n}\)</span>很接近。利用向量的点乘，我们可以判断两个向量是否接近。根据这两点我们可以简化高光的计算方式为：<span class="math display">\[\begin{gather*}\overrightarrow{h}=bisector(v,l)=\frac{v+l}{\|v+l\|} \\L_s=k_s(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p\end{gather*}\]</span> 为什么需要指数 <span class="math inline">\(p\)</span>？因为直接使用点乘计算的结果容忍度太高，会导致高光分布范围太大，高光边缘不明显。</p><p><img src="Snipaste_2023-12-07_10-26-19.png" style="zoom:50%;" /></p><p><img src="Snipaste_2023-12-07_10-29-21.png" style="zoom:50%;" /></p><p>为什么不考虑物体的角度对高光的影响？Blnn-Phong模型是一个简单的经验模型，实际上是需要的。</p></li><li><p>环境光（Ambient lighting）</p><p>Blnn-Phong模型对环境光非常简化，仅考虑环境光常数系数 <spanclass="math inline">\(I_a\)</span> <span class="math display">\[L_a=k_a+I_a\]</span> 事实上的环境光模型十分复杂。</p></li><li><p>总的来说，Blnn-Phong反射模型的算式为： <spanclass="math display">\[\begin{gather*}L=L_a+L_d+L_s\\=k_aI_a+k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})+max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p\end{gather*}\]</span></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - 作业1代码框架分析</title>
    <link href="/2023/12/05/Games101-%E4%BD%9C%E4%B8%9A1%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/05/Games101-%E4%BD%9C%E4%B8%9A1%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ul><li>作业1做的是完成 get_model_matrix() 和 get_projection_matrix()函数，只要计算和返回两个变换矩阵就可以了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_model_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> rotation_angle)</span></span><br><span class="hljs-function"></span>&#123;<br>    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the model matrix for rotating the triangle around the Z axis.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    <span class="hljs-type">float</span> sin_rotation_angle = <span class="hljs-built_in">sin</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    <span class="hljs-type">float</span> cos_rotation_angle = <span class="hljs-built_in">cos</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    model &lt;&lt;<br>    cos_rotation_angle, -sin_rotation_angle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    sin_rotation_angle, cos_rotation_angle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> model;<br>&#125;<br><br><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_projection_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> eye_fov, <span class="hljs-type">float</span> aspect_ratio,<span class="hljs-type">float</span> zNear, <span class="hljs-type">float</span> zFar)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Students will implement this function</span><br><br>    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the projection matrix for the given parameters.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    <span class="hljs-comment">// Matrix for M_persp -&gt; M_troho</span><br>    Eigen::Matrix4f M_persp_troth = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_persp_troth &lt;&lt; zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zNear + zFar, -(zNear * zFar),<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// value of l,f,t,b;</span><br>    <span class="hljs-type">float</span> top, bottom, left, right;<br>    top = <span class="hljs-built_in">tan</span>(eye_fov / <span class="hljs-number">2</span>) * <span class="hljs-built_in">abs</span>(zNear);<br>    bottom = (<span class="hljs-number">-1</span>) * top;<br>    right = aspect_ratio * top;<br>    left = (<span class="hljs-number">-1</span>) *right;<br><br>    <span class="hljs-comment">// Matrix for move to origin.</span><br>    Eigen::Matrix4f M_move = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_move &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">-1</span>) * (left + right) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">-1</span>) * (top + bottom) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (<span class="hljs-number">-1</span>) * (zNear +  zFar) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Matrix for scale.</span><br>    Eigen::Matrix4f M_scale = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_scale &lt;&lt;<br>    <span class="hljs-number">2</span> / (right - left), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (top - bottom), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (zNear - zFar), <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Matrix for ortho transformation.</span><br>    Eigen::Matrix4f M_ortho = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_ortho = M_scale * M_move;<br><br>    projection = M_ortho * M_persp_troth;<br><br>    <span class="hljs-keyword">return</span> projection;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>再来简单分析一下光栅器的代码，先从main入手：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> angle = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> command_line = <span class="hljs-literal">false</span>;<br>    std::string filename = <span class="hljs-string">&quot;output.png&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        command_line = <span class="hljs-literal">true</span>;<br>        angle = std::<span class="hljs-built_in">stof</span>(argv[<span class="hljs-number">2</span>]); <span class="hljs-comment">// -r by default</span><br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">4</span>) &#123;<br>            filename = std::<span class="hljs-built_in">string</span>(argv[<span class="hljs-number">3</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 定义一个700x700的光栅器，构造函数会根据参数创建二维数组frame_buf和deepth_buf</span><br>    <span class="hljs-function">rst::rasterizer <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>)</span></span>;<br>    <span class="hljs-comment">// 相机朝向的向量</span><br>    Eigen::Vector3f eye_pos = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 三角形的三个顶点坐标</span><br>    std::vector&lt;Eigen::Vector3f&gt; pos&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 应该是三角形的id，值的意义是对应的三个顶点在向量中的下标</span><br>    std::vector&lt;Eigen::Vector3i&gt; ind&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    rst::pos_buf_id rst::rasterizer::load_positions(const std::vector&lt;Eigen::Vector3f&gt; &amp;positions)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        auto id = get_next_id();</span><br><span class="hljs-comment">        pos_buf.emplace(id, positions);</span><br><span class="hljs-comment">        return &#123;id&#125;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    pos_buf是一个map，这个函数作用是为每个三角形坐标的顶点信息指定一个id，并存到下标为id的map中，最后返回该id</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">auto</span> pos_id = r.<span class="hljs-built_in">load_positions</span>(pos);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    rst::ind_buf_id rst::rasterizer::load_indices(const std::vector&lt;Eigen::Vector3i&gt; &amp;indices)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        auto id = get_next_id();</span><br><span class="hljs-comment">        ind_buf.emplace(id, indices);</span><br><span class="hljs-comment">        return &#123;id&#125;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    迷惑，为什么要这么写</span><br><span class="hljs-comment">    功能和load_positions类似，只不过换成了存储和标记下标</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-comment">//关于这两个函数如何工作详见draw方法</span><br>    <span class="hljs-keyword">auto</span> ind_id = r.<span class="hljs-built_in">load_indices</span>(ind);<br><br><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> frame_count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (command_line) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        void rst::rasterizer::clear(rst::Buffers buff)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if ((buff &amp; rst::Buffers::Color) == rst::Buffers::Color)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                std::fill(frame_buf.begin(), frame_buf.end(), Eigen::Vector3f&#123;0, 0, 0&#125;);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            if ((buff &amp; rst::Buffers::Depth) == rst::Buffers::Depth)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                std::fill(depth_buf.begin(), depth_buf.end(), std::numeric_limits&lt;float&gt;::infinity());</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        Buffers是一个枚举类型，clear函数的功能是如果深度或颜色参数与该枚举类中的值一样，则将深度无限大或颜色设置为(0,0,0)</span><br><span class="hljs-comment">        使用这个枚举类型以达到初始化frame_buf与depth_buf的目的</span><br><span class="hljs-comment">        */</span><br>        r.<span class="hljs-built_in">clear</span>(rst::Buffers::Color | rst::Buffers::Depth);<br><br>        <span class="hljs-comment">// 设置变换矩阵</span><br>        r.<span class="hljs-built_in">set_model</span>(<span class="hljs-built_in">get_model_matrix</span>(angle));<br>        r.<span class="hljs-built_in">set_view</span>(<span class="hljs-built_in">get_view_matrix</span>(eye_pos));<br>        <span class="hljs-comment">// 这里设置了光锥的fovY为45，aspect为1(700x700)，n为0.1与f为50，可以尝试修改观察变化</span><br>        r.<span class="hljs-built_in">set_projection</span>(<span class="hljs-built_in">get_projection_matrix</span>(<span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">50</span>));<br><br>        <span class="hljs-comment">// draw函数绘制三角形</span><br>        r.<span class="hljs-built_in">draw</span>(pos_id, ind_id, rst::Primitive::Triangle);<br>        <span class="hljs-function">cv::Mat <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>, CV_32FC3, r.frame_buffer().data())</span></span>;<br>        image.<span class="hljs-built_in">convertTo</span>(image, CV_8UC3, <span class="hljs-number">1.0f</span>);<br><br>        cv::<span class="hljs-built_in">imwrite</span>(filename, image);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 与上面的方法一样</span><br>    <span class="hljs-keyword">while</span> (key != <span class="hljs-number">27</span>) &#123;<br><br>        r.<span class="hljs-built_in">clear</span>(rst::Buffers::Color | rst::Buffers::Depth);<br><br>        r.<span class="hljs-built_in">set_model</span>(<span class="hljs-built_in">get_model_matrix</span>(angle));<br>        r.<span class="hljs-built_in">set_view</span>(<span class="hljs-built_in">get_view_matrix</span>(eye_pos));<br>        r.<span class="hljs-built_in">set_projection</span>(<span class="hljs-built_in">get_projection_matrix</span>(<span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">50</span>));<br><br>        r.<span class="hljs-built_in">draw</span>(pos_id, ind_id, rst::Primitive::Triangle);<br><br>        <span class="hljs-function">cv::Mat <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>, CV_32FC3, r.frame_buffer().data())</span></span>;<br>        image.<span class="hljs-built_in">convertTo</span>(image, CV_8UC3, <span class="hljs-number">1.0f</span>);<br>        cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;T_image&quot;</span>, image);<br>        key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">10</span>);<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;frame count: &quot;</span> &lt;&lt; frame_count++ &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            angle += <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;d&#x27;</span>) &#123;<br>            angle -= <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>draw函数功能是绘制三角形线框</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">draw</span>(rst::pos_buf_id pos_buffer, rst::ind_buf_id ind_buffer, rst::Primitive type)<br>&#123;<br>    <span class="hljs-keyword">if</span> (type != rst::Primitive::Triangle)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Drawing primitives other than triangle is not implemented yet!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据参数获得id</span><br>    <span class="hljs-keyword">auto</span>&amp; buf = pos_buf[pos_buffer.pos_id];<br>    <span class="hljs-keyword">auto</span>&amp; ind = ind_buf[ind_buffer.ind_id];<br><br>    <span class="hljs-comment">// 没用到不知道是干什么的</span><br>    <span class="hljs-type">float</span> f1 = (<span class="hljs-number">100</span> - <span class="hljs-number">0.1</span>) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-type">float</span> f2 = (<span class="hljs-number">100</span> + <span class="hljs-number">0.1</span>) / <span class="hljs-number">2.0</span>;<br><br>    <span class="hljs-comment">// 计算mvp变换矩阵</span><br>    Eigen::Matrix4f mvp = projection * view * model;<br>    <span class="hljs-comment">// 遍历每一个存储的ind</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : ind)<br>    &#123;<br>        Triangle t;<br><br>        <span class="hljs-comment">// 每个点做mvp变换</span><br>        Eigen::Vector4f v[] = &#123;<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">0</span>]], <span class="hljs-number">1.0f</span>),<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">1</span>]], <span class="hljs-number">1.0f</span>),<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">2</span>]], <span class="hljs-number">1.0f</span>)<br>        &#125;;<br><br>        <span class="hljs-comment">// 归一化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; vec : v) &#123;<br>            vec /= vec.<span class="hljs-built_in">w</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 变换到屏幕空间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; vert : v)<br>        &#123;<br>            vert.<span class="hljs-built_in">x</span>() = <span class="hljs-number">0.5</span>*width*(vert.<span class="hljs-built_in">x</span>()+<span class="hljs-number">1.0</span>);<br>            vert.<span class="hljs-built_in">y</span>() = <span class="hljs-number">0.5</span>*height*(vert.<span class="hljs-built_in">y</span>()+<span class="hljs-number">1.0</span>);<br>            vert.<span class="hljs-built_in">z</span>() = vert.<span class="hljs-built_in">z</span>() * f1 + f2;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置三个顶点的坐标，从每个齐次坐标中取前三个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>        &#123;<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>        &#125;<br><br><br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255.0</span>,  <span class="hljs-number">0.0</span>,  <span class="hljs-number">0.0</span>);<br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>  ,<span class="hljs-number">255.0</span>,  <span class="hljs-number">0.0</span>);<br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0.0</span>  ,  <span class="hljs-number">0.0</span>,<span class="hljs-number">255.0</span>);<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        void rst::rasterizer::rasterize_wireframe(const Triangle&amp; t)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            draw_line(t.c(), t.a());</span><br><span class="hljs-comment">            draw_line(t.c(), t.b());</span><br><span class="hljs-comment">            draw_line(t.b(), t.a());</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 光栅化三条线段，这个应该很好算</span><br>        <span class="hljs-built_in">rasterize_wireframe</span>(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>光栅器中使用了draw_line方法绘制线段，使用了由Bresenham提出的一种精确而有效的光栅线生成算法<strong>Bresenham'slinealgorithm</strong>，可用于显示线、圆和其他曲线的整数增量运算，是目前最有效的线段生成算法，推导可见：<ahref="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham'slinealgorithm wiki</a></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">draw_line</span>(Eigen::Vector3f begin, Eigen::Vector3f end)<br>&#123;<br>    <span class="hljs-keyword">auto</span> x1 = begin.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-keyword">auto</span> y1 = begin.<span class="hljs-built_in">y</span>();<br>    <span class="hljs-keyword">auto</span> x2 = end.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-keyword">auto</span> y2 = end.<span class="hljs-built_in">y</span>();<br><br>    Eigen::Vector3f line_color = &#123;<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;;<br><br>    <span class="hljs-type">int</span> x,y,dx,dy,dx1,dy1,px,py,xe,ye,i;<br><br>    dx=x2-x1;<br>    dy=y2-y1;<br>    dx1=<span class="hljs-built_in">fabs</span>(dx);<br>    dy1=<span class="hljs-built_in">fabs</span>(dy);<br>    px=<span class="hljs-number">2</span>*dy1-dx1;<br>    py=<span class="hljs-number">2</span>*dx1-dy1;<br><br>    <span class="hljs-keyword">if</span>(dy1&lt;=dx1)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dx&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            x=x1;<br>            y=y1;<br>            xe=x2;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            x=x2;<br>            y=y2;<br>            xe=x1;<br>        &#125;<br>        Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;x&lt;xe;i++)<br>        &#123;<br>            x=x+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(px&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                px=px+<span class="hljs-number">2</span>*dy1;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((dx&lt;<span class="hljs-number">0</span> &amp;&amp; dy&lt;<span class="hljs-number">0</span>) || (dx&gt;<span class="hljs-number">0</span> &amp;&amp; dy&gt;<span class="hljs-number">0</span>))<br>                &#123;<br>                    y=y+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    y=y<span class="hljs-number">-1</span>;<br>                &#125;<br>                px=px+<span class="hljs-number">2</span>*(dy1-dx1);<br>            &#125;<br><span class="hljs-comment">//            delay(0);</span><br>            Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dy&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            x=x1;<br>            y=y1;<br>            ye=y2;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            x=x2;<br>            y=y2;<br>            ye=y1;<br>        &#125;<br>        Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;y&lt;ye;i++)<br>        &#123;<br>            y=y+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(py&lt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                py=py+<span class="hljs-number">2</span>*dx1;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((dx&lt;<span class="hljs-number">0</span> &amp;&amp; dy&lt;<span class="hljs-number">0</span>) || (dx&gt;<span class="hljs-number">0</span> &amp;&amp; dy&gt;<span class="hljs-number">0</span>))<br>                &#123;<br>                    x=x+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    x=x<span class="hljs-number">-1</span>;<br>                &#125;<br>                py=py+<span class="hljs-number">2</span>*(dx1-dy1);<br>            &#125;<br><span class="hljs-comment">//            delay(0);</span><br>            Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_debug</title>
    <link href="/2023/12/05/hexo-debug/"/>
    <url>/2023/12/05/hexo-debug/</url>
    
    <content type="html"><![CDATA[<h4id="记录一下hexo使用过程中遇到的的bug以及解决方法">记录一下hexo使用过程中遇到的的bug以及解决方法</h4><ul><li><p><strong>render LateX公式过程出现错误：parseAggregate: expectedcomma after expression</strong></p><p>Google后发现是LateX公式中要将 '{' 或 '}'符号中间用空格隔开...</p></li></ul><hr /><p>持续更新中....</p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture06 Rasterization 2 (Antialiasing)</title>
    <link href="/2023/11/30/Games101-Lecture-06-Rasterization-2-Antialiasing/"/>
    <url>/2023/11/30/Games101-Lecture-06-Rasterization-2-Antialiasing/</url>
    
    <content type="html"><![CDATA[<h1 id="rasterization-2-antialiasing-and-z-buffering">Rasterization 2(Antialiasing and Z-Buffering)</h1><h3 id="sampling-artifacts">1. Sampling Artifacts</h3><ul><li><p><strong>什么是 Artifacts ？</strong></p><p>在计算机图形中的错误（Errors）、错误（Mistakes）、不准确（Inaccuracies）。</p></li><li><p><strong>常见的 Artifacts 有哪些？</strong></p><ul><li>锯齿（Jaggies）：空间采样</li><li>摩尔纹（Moire）：图形欠采样</li><li>车轮效应（Wagon wheel effect）：及时采样</li><li>还有很多......</li></ul></li><li><p><strong>为什么会产生这些 Artifacts ?</strong></p><p>信号变化太快（高频）但是采样速度太慢。</p></li><li><p><strong>如何解决这些问题？</strong></p><p><img src="Snipaste_2023-11-30_11-07-29.png" style="zoom: 67%;" /></p><p>在<strong>进行采样之前，对信号进行处理</strong>可以达到解决问题的效果。</p></li></ul><hr /><h3 id="frequency-domain">2. Frequency Domain</h3><ul><li><p><strong>什么是走样？</strong></p><p><img src="Snipaste_2023-11-30_16-44-30.png" style="zoom: 67%;" /></p><p>图示两个截然不同的函数，在相同采样方式下的采样结果却完全相同。</p><p><strong>同样的一种采样方法，采样两种频率不同的函数，得出的结果我们无法区分，这就是走样。</strong></p><p><img src="Snipaste_2023-11-30_17-31-09.png" style="zoom: 67%;" /></p><p>图示5个周期函数中我们可以看到，当函数频率越高时，采样后的结果与原函数的区别越明显。</p><p>也就是说，越高的频率需要越快的采样。</p></li><li><p><strong>什么是傅里叶展开？</strong></p><p>任何一个周期函数，都可以将其写成一系列正弦与余弦函数的线性组合以及一个常数项。</p><p><img src="Snipaste_2023-11-30_11-18-50.png" style="zoom: 50%;" /><img src="Snipaste_2023-11-30_11-19-51.png" style="zoom: 50%;" /></p><p>图示函数使用傅里叶展开： <span class="math display">\[f(x)=\frac{A}{2}+\frac{2A\cos{t\omega} }{\pi}+\frac{2A\cos{3t\omega} }{3\pi}+\frac{2A\cos{5t\omega} }{5\pi}+\frac{2A\cos{7t\omega} }{7\pi}+ ...\]</span> 每添加一项，都能更加逼近原函数。</p><p><img src="Snipaste_2023-11-30_16-57-10.png" style="zoom: 67%;" /></p><p>使用傅里叶变换可以得到这些展开的项。</p></li><li><p><strong>什么是傅里叶变换？</strong></p><p>所谓傅里叶变换，就是将函数分解为不同频率的段，并将这些段显示出来。</p><p>简单地讲，傅里叶变换可以将一个函数从时域变换到频域。</p><p>通过傅里叶变换，我们可以看到任何信号在不同的频域长什么样，也就是频谱。</p></li></ul><hr /><h3 id="filtering-convolution-averaging">3. Filtering = Convolution ( =Averaging)</h3><ul><li><p><strong>什么是滤波？</strong></p><p>将信号中特定的频段抹除后，对应的信号应发生什么变化。</p><ul><li><p>一张图片与其对应的频谱：</p><p><img src="Snipaste_2023-12-01_14-35-52.png" style="zoom: 50%;" /></p></li><li><p>经过高通滤波后的图像，仅保留了高频的信息（物体边界）：</p><p><img src="Snipaste_2023-12-01_14-38-44.png" style="zoom: 50%;" /></p></li></ul></li><li><p><strong>什么是卷积？</strong></p><ul><li><p>如何做卷积（图形学上）：</p><p><img src="Snipaste_2023-12-01_14-46-50.png" style="zoom: 67%;" /></p><p>将每个信号对应的段与滤波进行点乘，点乘的结果是该段的中心卷积后的值。</p></li><li><p>卷积的定理</p><ul><li>两个信号在时域上的卷积等于这两个信号在频域上的乘积，反之亦然；</li><li>卷积的结果等于将信号傅里叶变换到频域上乘积后再逆傅里叶变换到时域的结果；</li></ul></li></ul></li><li><p><strong>卷积的使用</strong></p><ul><li><p>模糊处理</p><p><img src="Snipaste_2023-12-01_14-58-50.png" style="zoom: 67%;" /></p><p>模糊处理的卷积核是一个低通滤波器，卷积核越大，模糊处理效果越明显。</p></li></ul></li></ul><hr /><h3 id="sampling-in-frequency-domaitn">4. Sampling in FrequencyDomaItn</h3><ul><li><p><strong>什么是采样（从频域上看）？</strong></p><p>采样就是在重复频域上的内容。</p><p><img src="Snipaste_2023-12-01_15-11-11.png"  /></p><p>​将信号与冲激函数进行傅里叶变换后，计算二者的乘积，可以看出采样就是在重复频域上的内容，这是因为在时域中以固定间隔采样相当于在频域中以相邻频率间隔复制原始频谱。</p></li><li><p><strong>什么是走样（从频域上看）？</strong></p><p><img src="Snipaste_2023-12-01_15-22-35.png" /></p><p>因为采样的速度不够快，采样时复制原始频谱的间隔太小，复制的频谱之间太密集导致频谱混叠在一起。</p></li></ul><hr /><h3 id="antialiasing">5. Antialiasing</h3><ul><li><p><strong>终极办法——增加采样率</strong></p><p>​当屏幕上的像素点越密集，像素越多，采样率越快，频谱上表现为相邻复制频谱的间隔变大，就可以从根本上解决走样问题，但也受到物理限制。</p></li><li><p><strong>反走样（抗锯齿）</strong></p><ul><li><p>MSAA（Antialiasing By Supersampling）</p><p><img src="Snipaste_2023-12-01_15-49-15.png" /></p><p>将原始图像进行模糊处理，即将原始频谱变短（去掉高频），可以有效地防止发生混叠。</p><p><img src="Snipaste_2023-11-30_11-07-29.png" /></p><p>那么如何对图像进行模糊处理呢？</p><ul><li><p>模糊操作（卷积）：用每一个像素对应的box做卷积操作，根据得到平均值填充该像素</p><p><img src="Snipaste_2023-12-01_15-57-30.png" /></p><p>将一个像素内部划分为很多个小像素，增加其采样点，通过计算小像素被三角形覆盖的数量，计算三角形在每个像素中的覆盖率：</p><p><img src="Snipaste_2023-12-01_16-12-08.png" style="zoom:50%;" /><img src="Snipaste_2023-12-01_16-08-53.png" style="zoom:50%;" /></p><p><img src="Snipaste_2023-12-01_16-17-23.png" style="zoom:80%;" /></p><p><strong>通过MSAA只能提高三角形在每个像素中的覆盖率的计算精确度，并没有实际提高采样率。</strong></p></li><li><p>使用MSAA的代价：将像素细分必将带来很多的计算量。但MSAA在实际应用中并不会只是单纯细分为规则的像素点，相邻的像素点间也可能复用，因此MSAA的效率也并不是那么低。</p></li></ul></li><li><p>FXAA（Fast Approximate AA）</p><p>快速近似抗锯齿的方法是先得到一幅带锯齿的图像，再通过图像匹配的方式找到有锯齿的边界，再将其换成不带锯齿的边界。FXAA与采样无关，是一种在图像层面的抗锯齿方法。</p></li><li><p>TAA（Temporal AA）</p><p>TAA的方法是在同一像素的不同帧内采用不同位置的采样，并在后来的帧内复用这些采样。相当于将MSAA对应的样本给分布到了时间上，并且当前帧不做额外操作（静态）。</p></li></ul></li><li><p>超分辨率</p><p>将一副采样率不足的高分辨率图像缺失的采样恢复出来。</p><p>DLSS（Deep Learning SuperSampling）：采用深度学习将缺失的采样恢复。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture05 Rasterization 1 (Triangles)</title>
    <link href="/2023/11/28/Games101-Lecture-05-Rasterization-1-Triangles/"/>
    <url>/2023/11/28/Games101-Lecture-05-Rasterization-1-Triangles/</url>
    
    <content type="html"><![CDATA[<h1 id="rasterization-1-triangles">Rasterization 1 (Triangles)</h1><h3 id="canonical-cube-to-screen">1. Canonical Cube to Screen</h3><ul><li><p><strong>什么是屏幕？</strong></p><p><img src="Snipaste_2023-11-28_15-36-39.png" style="zoom:33%;" /></p><p>屏幕一般被定义为一个二维数组，从(0,0)开始，每个像素的坐标是其所在方块的左下角的坐标值。</p></li><li><p><strong>如何将标准立方体映射到屏幕上？(视口变换)</strong></p><ul><li><p>改变换与Z轴无关；</p></li><li><p>将 <span class="math inline">\([-1,1]^2\)</span> 变换到 <spanclass="math inline">\([0,width]\times[0,height]\)</span> ： <spanclass="math display">\[M_{viewport}=\begin{pmatrix}    \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\    0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\    0 &amp; 0 &amp; 1 &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li></ul></li></ul><h3 id="triangles-meshes">2. Triangles MEshes</h3><ul><li><p><strong>为什么三角形会在图形学中得到广泛应用？</strong></p><ul><li>三角形是最基本的多边形；</li><li>可以将其他多边形分解为三角形；</li><li>三角形内部一定是平面的；</li><li>三角形内外的定义十分清晰；</li><li>定义三角形三个顶点的属性，可以有规律地对三角形内部地点地属性进行插值（重心插值）；</li></ul></li><li><p>一种简单的光栅化的方法：采样</p><ul><li><p><strong>什么是采样？</strong></p><p>给定一个连续的函数，对任意一个点询问该点的函数值是多少。采样是将一个函数离散化的过程。</p><p><img src="Snipaste_2023-11-30_10-08-14.png" style="zoom: 25%;" /><spanclass="math inline">\(\Rightarrow\)</span><img src="Snipaste_2023-11-30_10-11-00.png" style="zoom:25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; xmax; x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; ymax; y++)&#123;<br>image[x][y] = <span class="hljs-built_in">inside</span>(tri, x + <span class="hljs-number">0.5</span>, y + <span class="hljs-number">0.5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Bounding Box!</strong> （AABB）</p><p>采样时有许多优化方式，最简单的一种就是 BoundingBox，通过三个顶点的坐标判断循环的范围，减少无效计算。</p><p><img src="src\Snipaste_2023-11-30_10-16-58.png" style="zoom:25%;" /></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture04 Transformation Cont</title>
    <link href="/2023/11/27/Games101-Lecture-04-Transformation-Cont/"/>
    <url>/2023/11/27/Games101-Lecture-04-Transformation-Cont/</url>
    
    <content type="html"><![CDATA[<h1 id="transformation">Transformation</h1><h3 id="d-modeling-transformation">1. 3D Modeling Transformation</h3><ul><li><p><strong>简单的三维变换</strong></p><ul><li><p>缩放 <span class="math display">\[S(s_x,s_y,s_z)=\begin{pmatrix}    s_x &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; s_y &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; s_z &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li><li><p>平移 <span class="math display">\[T(t_x,t_y,t_z)=\begin{pmatrix}    1 &amp; 0 &amp; 0 &amp; t_x \\    0 &amp; 1 &amp; 0 &amp; t_y \\    0 &amp; 0 &amp; 1 &amp; t_z \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li><li><p>简单绕轴旋转 <span class="math display">\[R_x(\alpha)=\begin{pmatrix}    1 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; \cos\alpha &amp; -\sin\alpha &amp; 0 \\    0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p><span class="math display">\[R_y(\alpha)=\begin{pmatrix}    \cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 \\    -\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p><span class="math display">\[R_z(\alpha)=\begin{pmatrix}    \cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\    \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li></ul></li><li><p><strong>罗德里格斯旋转公式 (Rodrigues' RotationFormula)</strong></p><p>定义一个旋转角度 <span class="math inline">\(\alpha\)</span>与一条经过原点的旋转轴 <spanclass="math inline">\(\mathbf{n}\)</span>，则 <spanclass="math display">\[\mathbf{R}(\mathbf{n},\alpha)=\cos(\alpha)~\mathbf{I} + (1-\cos(\alpha))~\mathbf{n}\mathbf{n}^T +\sin\alpha~\underbrace{\begin{pmatrix}  0 &amp; -n_z &amp; -n_y \\  n_z &amp; 0 &amp; -n_x \\  -n_y &amp; n_x &amp; 0\end{pmatrix} }_{\mathbf{N} }\]</span></p></li></ul><hr /><h3 id="viewing-transformation">2. Viewing transformation</h3><ul><li><p><strong>View / Camera transformation</strong></p><p>如何进行视图变换？</p><ul><li><p>定义相机：</p><p><img src="Snipaste_2023-11-27_10-20-49.png" style="zoom: 33%;" /></p><ul><li>位置 <span class="math inline">\(\overrightarrow{e}\)</span></li><li>朝向 <span class="math inline">\(\hat{g}\)</span></li><li>向上的方向 <span class="math inline">\(\hat{t}\)</span></li></ul></li><li><p>为了简化变换，我们可以使相机与模型的相对位置不变，固定相机位置：</p><p><img src="Snipaste_2023-11-27_10-31-54.png" style="zoom:38%;" /></p><ul><li><p>移动并固定相机位置在原点</p></li><li><p>旋转并固定相机为以Y轴为向上方向</p></li><li><p>旋转并固定相机朝向-Z</p></li><li><p>同时变换除相机以外的模型</p><p><img src="Snipaste_2023-11-27_10-37-07.png" style="zoom:33%;" /></p></li></ul><p>由于相机是设定好的，固定的，虚拟出来的，也就是视图变换本质上只是在对模型进行变换，因此模型变换与视图变换常被一起称为模型视图变换。</p></li><li><p>使用数学表示视图变换：</p><p>定义 <spanclass="math inline">\(M_{view}=R_{view}T_{view}\)</span>，</p><ul><li><p>平移到原点 $ <spanclass="math display">\[\begin{gather*}T_{view}=\begin{pmatrix}1&amp;0&amp;0&amp;-x_e\\0&amp;1&amp;0&amp;-y_e\\0&amp;0&amp;1&amp;-z_e\end{pmatrix}\end{gather*}\]</span>$</p></li><li><p>旋转 <span class="math inline">\(g\)</span> 到 <spanclass="math inline">\(-Z\)</span>，<spanclass="math inline">\(t\)</span> 到 <spanclass="math inline">\(Y\)</span>，<span class="math inline">\((g\timest)\)</span> 到 <spanclass="math inline">\(X\)</span>，对此我们可以求逆变换：</p><p>旋转 <span class="math inline">\(X\)</span> 到 <spanclass="math inline">\((g\times t)\)</span>，<spanclass="math inline">\(Y\)</span> 到 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(Z\)</span>到 <span class="math inline">\(-g\)</span> ，可得： <spanclass="math display">\[{R_{view} }^{-1}=\begin{bmatrix}  x_{\hat{g}\times\hat{t} } &amp; x_t &amp; x_{-g} &amp; 0 \\  y_{\hat{g}\times\hat{t} } &amp; y_t &amp; y_{-g} &amp; 0 \\  z_{\hat{g}\times\hat{t} } &amp; z_t &amp; z_{-g} &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> 由于旋转的变换矩阵为正交矩阵，可得： <spanclass="math display">\[{R_{view}={ {(R_{view} }^{-1})} }^T=\begin{bmatrix}  x_{\hat{g}\times\hat{t} } &amp; y_{\hat{g}\times\hat{t} } &amp;z_{\hat{g}\times\hat{t} } &amp; 0 \\  x_t &amp; y_t &amp; z_t &amp; 0 \\  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p></li></ul></li></ul></li></ul><hr /><h3 id="projection-transformation">3. Projection Transformation</h3><ul><li><p><strong>什么是投影变换？</strong></p><p>投影变换分为正交投影与透视投影，二者的区别十分明显：</p></li></ul><p><img src="Snipaste_2023-11-28_10-02-59.png" style="zoom:33%;" /></p><ul><li><p><strong>正交投影</strong></p><p>正交投影是一种假设相机处于无限远的投影方式（忽略了模型的前后关系）。</p><ul><li><p>一种简单的正交投影方式：</p><p><img src="Snipaste_2023-11-28_10-09-12.png" style="zoom:33%;" /></p><ul><li><p>固定相机；</p></li><li><p>丢掉 Z 轴；</p></li><li><p>将模型平移与缩放，使其全部位于 <spanclass="math inline">\([-1,1]^2\)</span> 的矩形范围内。</p></li></ul></li><li><p>常用的正交投影的方式：</p><p><img src="Snipaste_2023-11-28_10-18-20.png" style="zoom:33%;" /></p><p>定义一个立方体 <spanclass="math inline">\([l,r]\times[b,t]\times[f,n]\)</span>与一个标准立方体 <span class="math inline">\([-1,1]^3\)</span>，</p><ul><li>通过先平移后缩放的方式，将立方体投影到标准立方体中。</li></ul><p>使用数学表示投影，先将立方体的中心移动到原点，再将其缩放到标准立方体内：<span class="math display">\[M_{ortho}=\begin{bmatrix}    \frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}    1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\    0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\    0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\    0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p></li></ul></li><li><p><strong>透视投影</strong></p><p>透视投影可以达到近大远小的效果。</p><ul><li><p>透视投影的方式：</p><p><img src="Snipaste_2023-11-28_10-35-45.png" style="zoom:33%;" /></p><ul><li><p>思路：将视锥“挤压”成一个立方体，再将立方体正交投影到标准立方体中；（<spanclass="math inline">\(M_{persp}\rightarrow M_{ortho}\)</span>）</p></li><li><p>对于“挤压”的过程，定义近远都平面不变，远平面中心点不变；</p></li><li><p>从侧面看：</p><p><img src="Snipaste_2023-11-28_10-55-30.png" style="zoom:33%;" /></p><p>根据相似三角形的性质，可得 <span class="math display">\[\begin{gather*}y&#39;=\frac{n}{z}y \\x&#39;=\frac{n}{z}x\end{gather*}\]</span> 根据这点，可得投影变换后的坐标： <span class="math display">\[\begin{pmatrix}  x \\ y \\ z \\ 1\end{pmatrix}\Rightarrow\begin{pmatrix}  \frac{n}{z}x \\ \frac{n}{z}y \\ ? \\ 1\end{pmatrix}=\begin{pmatrix}  nx \\ ny \\ ? \\ z\end{pmatrix}\]</span> 再逆向求投影变换的变换矩阵，已知： <spanclass="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}\begin{pmatrix}  x \\ y \\ z \\1\end{pmatrix} =\begin{pmatrix}  nx \\ ny \\ ? \\ z\end{pmatrix}\]</span> 可求得： <span class="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}=\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  ? &amp; ? &amp; ? &amp; ? \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\]</span></p></li><li><p>因为近平面上的点不变，设变换一个位于近平面上的点 <spanclass="math inline">\(\begin{pmatrix}x&amp;y&amp;n&amp;1\end{pmatrix}^T\)</span>，可得该点被“压缩”后坐标不变：<span class="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}=\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  ? &amp; ? &amp; ? &amp; ? \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}\Rightarrow\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}=\begin{pmatrix}  nx \\ ny \\ n^2 \\ n\end{pmatrix}\]</span> 即 <span class="math inline">\(\begin{pmatrix} C &amp; D &amp;A &amp; B \end{pmatrix} \begin{pmatrix} x \\ y \\ n \\ 1 \end{pmatrix} =n^2\)</span> , 由于 x , y 与 n 无关，因此可以确定 C = D = 0 ，但无法确认A 与 B 的值。</p><p>由 <span class="math inline">\(\begin{pmatrix} 0 &amp; 0 &amp; A&amp; B \end{pmatrix} \begin{pmatrix} x \\ y \\ n \\ 1 \end{pmatrix} =n^2\)</span> ，可得 <spanclass="math inline">\(An+B=n^2\)</span>；</p></li><li><p>又因为远平面上的中心点不变，设远平面上中心点为 <spanclass="math inline">\(\begin{pmatrix}0&amp;0&amp;f&amp;1\end{pmatrix}^T\)</span>，同理可得：<span class="math display">\[\begin{pmatrix}      0 \\ 0 \\ f \\ 1  \end{pmatrix}  \Rightarrow  \begin{pmatrix}      0 \\ 0 \\ f \\ 1  \end{pmatrix}  =  \begin{pmatrix}      0 \\ 0 \\ f^2 \\ f  \end{pmatrix}  \Rightarrow  Af+B=f^2\]</span> 联立： <span class="math display">\[\begin{gather*}An+B=n^2\\Af+B=f^2\end{gather*}\]</span> 可解得： <span class="math display">\[\begin{gather*}A=n+f\\B=-nf\end{gather*}\]</span></p></li><li><p>最后可得，投影变换矩阵为： <span class="math display">\[\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; n+f &amp; -nf \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\]</span></p></li></ul></li></ul></li><li><p><strong>如何定义一个视锥？</strong></p><p><img src="Snipaste_2023-11-28_15-02-47.png" style="zoom:33%;" /></p><ul><li><p>定义视锥的长宽比（aspect）与垂直可视角度（fovY）；</p><p><img src="Snipaste_2023-11-28_15-14-30.png" style="zoom:33%;" /></p></li><li><p>如何将 aspect 与 fovY 转换成 l, r, b, t ？ <spanclass="math display">\[\begin{gather*}\tan{\frac{fovY}{2} }=\frac{t}{\lvert n \rvert} \\aspect = \frac{r}{t}\end{gather*}\]</span></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture03 Transformation</title>
    <link href="/2023/11/25/Games101-Lecture-03-Transformation/"/>
    <url>/2023/11/25/Games101-Lecture-03-Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="transformation">Transformation</h1><h3 id="mvp-transformation">1. MVP Transformation</h3><ul><li><p><strong>什么是MVP变换？</strong></p><p>Model Transfors + View Transfors + Projection Transfors</p></li></ul><hr /><h3 id="d-modeling-transformations">2. 2D modeling transformations</h3><ul><li><p><strong>使用矩阵表示线性变换</strong></p><ul><li><p>缩放</p><p><img src="Snipaste_2023-11-25_18-12-06.png" alt="Snipaste_2023-11-25_18-12-06" style="zoom: 33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    s &amp; 0 \\    0 &amp; s\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>缩放（非对称）</p><p><img src="image-20231125181622307.png" style="zoom:33%;" /> <spanclass="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    s_x &amp; 0 \\    0 &amp; s_y\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>镜像（反射）</p><p><img src="image-20231125181820508.png" style="zoom:33%;" /> <spanclass="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    -1 &amp; 0 \\    0 &amp; 1\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>切变</p><p><img src="image-20231125182005285.png" style="zoom:33%;" /> <spanclass="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    1 &amp; a \\    0 &amp; 1\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>旋转</p><p><img src="image-20231125190114296.png" style="zoom:33%;" /> <spanclass="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    \cos\theta &amp; -\sin\theta \\    \sin\theta &amp; \cos\theta\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span> 当旋转 <span class="math inline">\(-\theta\)</span>角度时，容易发现： <span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=R_{-45}\cdot\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    \cos\theta &amp; \sin\theta \\    -\sin\theta &amp; \cos\theta\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}={R_{45}}^T\cdot\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}\]</span> 又因 $ R_{-45}={R_{45}}^{-1}$,</p><p>因此 $ R_{-45}={R_{45}}<sup>{-1}={R_{45}}</sup>T$ ,该变换矩阵为正交矩阵。</p></li></ul></li></ul><hr /><h3 id="homogeneous-coordinates">3. Homogeneous coordinates</h3><ul><li><p><strong>为什么要引入齐次坐标？</strong></p><p><img src="image-20231125193639426.png" style="zoom:33%;" /></p><p>这是一个简单的平移操作 ，我们知道移动后的图像各点坐标为： <spanclass="math display">\[x&#39;=x+t_x \\y&#39;=y+t_y\]</span>但在将其写成矩阵的表示方式时就会发现，不能将其像其他线性变换一样表示出来：<span class="math display">\[\begin{bmatrix}  x&#39; \\  y&#39;\end{bmatrix}=\begin{bmatrix}  a &amp; -b \\  c &amp; d\end{bmatrix}\begin{bmatrix}  x \\  y\end{bmatrix}+\begin{bmatrix}  t_x \\  t_y\end{bmatrix}\]</span>那么有没有一种办法可以<strong>将缩放、旋转等线性变换与平移等非线性变换用一种简单的变换表示</strong>呢？</p><p>为了解决这个问题，我们引入了齐次坐标。</p></li><li><p><strong>什么是齐次坐标？</strong></p><p>在原本坐标的基础上添加一个维度：</p><ul><li>2D的点 <span class="math inline">\(=(x,y,1)^T\)</span></li><li>2D向量 <span class="math inline">\(=(x,y,0)^T\)</span></li></ul><p>因为向量在空间中的位置不同并不会对向量的值产生任何变化，因此向量的新的一维值为0。</p><p><strong>新增的维度的值使得齐次坐标的运算结果依旧满足以下等式</strong></p><ul><li><p><span class="math inline">\(vector + vector =vector\)</span></p></li><li><p><span class="math inline">\(point - point =vector\)</span></p></li><li><p><span class="math inline">\(point + vector =point\)</span></p></li></ul></li><li><p><strong>齐次坐标的扩充定义</strong></p><ul><li><p>在齐次坐标中，当 <span class="math inline">\(w\neq0\)</span>时，<span class="math inline">\(\begin{pmatrix} x \\ y \\ w\end{pmatrix}\)</span> 表示一个坐标为 <spanclass="math inline">\(\begin{pmatrix} x/w \\ y/w \\ 1\end{pmatrix}\)</span> 的二维的点。</p><p>则 <span class="math inline">\(point + point\)</span>的值为两个点的中点。</p></li></ul></li><li><p><strong>使用齐次坐标表示变换</strong></p><ul><li><p>平移 <span class="math display">\[\begin{pmatrix}    x&#39; \\    y&#39; \\    1\end{pmatrix} =\begin{pmatrix}    a &amp; b &amp; t_x \\    c &amp; d &amp; t_y \\    0 &amp; 0 &amp; 1\end{pmatrix}\begin{pmatrix}    x \\    y \\    1\end{pmatrix}\]</span> 通过改变 <span class="math inline">\(a、b、c、d\)</span>的值，可以做到表示线性变换，例如：</p></li><li><p>旋转 <span class="math display">\[\begin{pmatrix}    x&#39; \\    y&#39; \\    1\end{pmatrix} =\begin{pmatrix}    \cos\theta &amp; -\sin\theta &amp; 0 \\    \sin\theta &amp; \cos\theta &amp; 0 \\    0 &amp; 0 &amp; 1\end{pmatrix}\begin{pmatrix}    x \\    y \\    1\end{pmatrix}\]</span></p></li></ul></li></ul><hr /><h3 id="composite-transformation">4. Composite Transformation</h3><ul><li><p><strong>表示变换的合成时遇到的问题？</strong></p><p><img src="Snipaste_2023-11-26_15-12-28.png" alt="Snipaste_2023-11-26_15-12-28" style="zoom:33%;" /></p><p><img src="Snipaste_2023-11-26_15-13-26.png" alt="Snipaste_2023-11-26_15-13-26" style="zoom:33%;" /></p><p>由图可知，相同的变换在使用不同变换顺序的情况下，得到的结果并不相同，即：<span class="math display">\[R_{45}\cdot T_{(1,0)} \neq T_{(1,0)}\cdot R_{45}\]</span>所以，在合成多个变换时，应该注意计算的顺序，顺序为<strong>从向量的左侧最近的变换矩阵开始运算</strong>。</p><p>例如，进行先旋转 <span class="math inline">\(45\degree\)</span>后向右平移 <span class="math inline">\(1\)</span> 个单位距离应表示为：<span class="math display">\[T_{(1,0)}\cdot R_{45} \cdot\begin{bmatrix}  x \\  y \\  1\end{bmatrix}\]</span></p><p>另外，当平移与线性变换表示为同一个矩阵，计算时先进性线性变换，再进行平移变换。</p></li><li><p><strong>合成变换的推广</strong></p><p>对向量 <span class="math inline">\(\overrightarrow{S}\)</span>应用n个变换 <spanclass="math inline">\(A_1,A_2,A_3,...,A_n\)</span>，可以表示为： <spanclass="math display">\[A_n ...A_2\cdot A_1\cdot\overrightarrow{S}\]</span>虽然矩阵的乘法不满足交换律，但满足结合律。即我们可以先将n个变换 <spanclass="math inline">\(A_1,A_2,A_3,...,A_n\)</span>相乘得到一个复杂的矩阵，这个矩阵可以表示一种十分复杂的变换。</p></li><li><p><strong>变换的分解</strong></p><p><img src="Snipaste_2023-11-27_08-18-45.png" alt="Snipaste_2023-11-27_08-18-45" style="zoom:38%;" /></p><p>有些变换可能是不常规的，无法用简单的变换进行转换。对此，我们需要对变换进行分解，例如将以上图形绕<span class="math inline">\(c\)</span> 点旋转，该变换可以分解为：</p><ul><li>将图形平移 <span class="math inline">\(-c\)</span></li><li>旋转图形</li><li>将图形平移 <span class="math inline">\(c\)</span></li></ul><p>即 <span class="math inline">\(T(c)R(\alpha)T(-c)\)</span></p></li></ul><hr /><h3 id="d-modeling-transformation">5. 3D Modeling Transformation</h3><ul><li><p><strong>三维中的齐次坐标</strong></p><p>同二维的齐次坐标，添加第四维：</p><ul><li>3D的点 $ =(x,y,z,1)$</li><li>3D向量 <span class="math inline">\(=(x,y,z,0)\)</span></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture02 Review of Linear Algebra</title>
    <link href="/2023/11/22/Games101-Lecture-02-Review-of-Linear-Algebra/"/>
    <url>/2023/11/22/Games101-Lecture-02-Review-of-Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="review-of-linear-algebra">Review of Linear Algebra</h1><h3 id="vector-addition">1. Vector Addition</h3><ul><li><strong>平行四边形法则与三角形法则</strong></li></ul><p><img src="image-20231122225034808.png" alt="image-20231122225034808" style="zoom: 67%;" /></p><ul><li><p><strong>坐标系</strong></p><p><img src="image-20231122232540795.png" alt="image-20231122232540795" style="zoom:67%;" /></p></li></ul><p>​ 缺省时一般认为向量为列向量: <span class="math display">\[\mathbf{A}=\begin{pmatrix}    x \\    y\end{pmatrix}\tag1\]</span></p><p><span class="math display">\[\mathbf{A^T}=\begin{pmatrix}    x &amp; y\end{pmatrix} \tag2\]</span></p><p><span class="math display">\[\|\mathbf{A}\|=\sqrt{x^2+y^2} \tag3\]</span></p><hr /><h3 id="vector-multiplication-dot-product">2. Vector Multiplication (DotProduct)</h3><ul><li><p><strong>点乘的计算</strong></p><p><img src="image-20231122230307232.png" style="zoom:67%;" /></p><p><strong>向量点乘的结果是一个数。</strong></p></li></ul><p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\|\overrightarrow{a}\|\|\overrightarrow{b}\|\cos\theta\tag1\]</span></p><p><span class="math display">\[\cos\theta=\frac{\overrightarrow{a}\cdot\overrightarrow{b}}{\|\overrightarrow{a}\|\|\overrightarrow{b}\|}\tag2\]</span></p><p>​ 当两个向量都是单位向量时（长度都为1）： <spanclass="math display">\[\cos\theta=\hat{a}\cdot\hat{b}\]</span></p><ul><li><p><strong>点乘的性质</strong></p><ul><li><p><spanclass="math inline">\(\overrightarrow{a}\cdot\overrightarrow{b}=\overrightarrow{b}\cdot\overrightarrow{a}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\cdot(\overrightarrow{b}+\overrightarrow{c})=\overrightarrow{a}\cdot\overrightarrow{b}+\overrightarrow{a}\cdot\overrightarrow{c}\)</span></p></li><li><p><spanclass="math inline">\((k\overrightarrow{a})\cdot=\overrightarrow{a}\cdot(k\overrightarrow{a})=k(\overrightarrow{a}\cdot\overrightarrow{b})\)</span></p></li></ul></li><li><p><strong>笛卡尔坐标系下的点乘运算</strong></p></li></ul><p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\begin{pmatrix}    x_a \\    y_a\end{pmatrix}\cdot\begin{pmatrix}    x_b \\    y_b\end{pmatrix}=x_ax_b+y_ay_b\]</span></p><p>​ <strong>点乘最大的作用在于找到两个向量之间的夹角大小。</strong></p><ul><li><strong>通过点乘求向量在另一个向量上的投影</strong></li></ul><p>​点乘的另一个作用是用于<strong>找到一个向量在另一个向量上的投影</strong>：</p><p><img src="image-20231123172442079.png" style="zoom:67%;" /></p><p>​ <span class="math inline">\(\overrightarrow{b}_\bot\)</span> 是<span class="math inline">\(\overrightarrow{b}\)</span> 在 <spanclass="math inline">\(\overrightarrow{a}\)</span> 方向上的投影，因此：<span class="math display">\[\overrightarrow{b_\bot}=k\hat{a}\]</span> ​ 其中 k 的大小为： <span class="math display">\[k=\|\overrightarrow{b_\bot}\|=\|\overrightarrow{b}\|\cos{\theta}\]</span> ​ 利用点乘计算出 <spanclass="math inline">\(\cos{\theta}\)</span> 后便可以求出 <spanclass="math inline">\(\overrightarrow{b_\bot}\)</span> 。</p><p>​<strong>已知向量在另一个向量上的投影后，可以对该向量任意地进行平行与垂直的分解</strong>：</p><p><img src="image-20231123184130756.png" style="zoom:67%;" /></p><ul><li><p><strong>通过点乘计算向量间的位置关系</strong></p><p><img src="image-20231123195107566.png" style="zoom:67%;" /></p><p>​ 以向量 <span class="math inline">\(\overrightarrow{a}\)</span>的方向为基准定义前与后，当一个向量与向量 <spanclass="math inline">\(\overrightarrow{a}\)</span>的点乘大于0时，称该向量位于前方。反之，当一个向量与向量 <spanclass="math inline">\(\overrightarrow{a}\)</span>的点乘小于0时，称该向量位于后方。</p><p>​<strong>两个向量的单位向量的点乘越接近1，则这两个向量在方向上越接近。</strong></p></li></ul><hr /><h3 id="vector-multiplication-times-product">3 Vector Multiplication(times Product)</h3><ul><li><p><strong>叉乘的计算</strong></p><p><img src="image-20231123200453651.png" style="zoom:67%;" /></p></li></ul><p>​<strong>两个向量叉乘的计算结果是一个垂直于这两个向量所在平面的向量。</strong><span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=-\overrightarrow{b}\times\overrightarrow{a}\tag1\]</span></p><p><span class="math display">\[\|\overrightarrow{a}\times\overrightarrow{b}\|=\|\overrightarrow{a}\|\|\overrightarrow{b}\|\sin{\phi}\tag2\]</span></p><p>​利用叉乘可以建立一个在三维空间中的直角坐标系（使用右手螺旋定则可以确定运算结果的向量的方向）：<span class="math display">\[\overrightarrow{x}\times\overrightarrow{y}=+\overrightarrow{z} \tag1\]</span></p><p><span class="math display">\[\overrightarrow{y}\times\overrightarrow{x}=-\overrightarrow{z} \tag2\]</span></p><p><span class="math display">\[\overrightarrow{y}\times\overrightarrow{z}=+\overrightarrow{x} \tag3\]</span></p><p><span class="math display">\[......\]</span></p><ul><li><p><strong>叉乘的性质</strong></p><ul><li><p><spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{b}=-\overrightarrow{b}\times\overrightarrow{a}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{a}=\overrightarrow{0}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times(\overrightarrow{b}+\overrightarrow{c})=\overrightarrow{a}\times\overrightarrow{b}+\overrightarrow{a}\times\overrightarrow{c}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times(k\overrightarrow{b})=k(\overrightarrow{a}\times\overrightarrow{b})\)</span></p></li></ul></li><li><p><strong>笛卡尔坐标系下的叉乘运算</strong> <spanclass="math display">\[\overrightarrow{a}\times\overrightarrow{b}=\begin{pmatrix}  y_az_b-y_bz_a \\  z_ax_b-x_az_b \\  x_ay_b-y_ax_b\end{pmatrix}\]</span></p></li><li><p><strong>叉乘的作用</strong></p></li></ul><p>​ <strong>判断某一点是否在图形的内部</strong>。</p><p>​ <img src="image-20231124152224648.png" style="zoom:33%;" /></p><p>​ 如图，<spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{b}\)</span>的值为正，可得 <span class="math inline">\(\overrightarrow{b}\)</span>在 <span class="math inline">\(\overrightarrow{a}\)</span>的左侧，反之同理，可以判断两个向量的相对左右位置。</p><p><img src="image-20231124152552096.png" style="zoom: 33%;" /></p><p>​要判断点P是否在顺序的，首尾相接的三个向量组成的三角形内部，则只需要计算<spanclass="math inline">\(\overrightarrow{AB}\times\overrightarrow{AP}\)</span>、<spanclass="math inline">\(\overrightarrow{BC}\times\overrightarrow{BP}\)</span>、<spanclass="math inline">\(\overrightarrow{CA}\times\overrightarrow{CP}\)</span>的值是否都为正值或负值，即点P都在三个向量的左侧或右侧。</p><hr /><h3 id="orthonormal-bases-and-coordinate-frames">4. Orthonormal basesand coordinate frames</h3><ul><li><p>建立一个直角坐标系，定义： <span class="math display">\[\|\overrightarrow{u}\|=\|\overrightarrow{v}\|=\|\overrightarrow{w}\|=1\tag1\]</span></p><p><span class="math display">\[\overrightarrow{u}\cdot\overrightarrow{v}=\overrightarrow{v}\cdot\overrightarrow{w}=\overrightarrow{u}\cdot\overrightarrow{w}=0\tag2\]</span></p><p><span class="math display">\[\overrightarrow{w}=\overrightarrow{u}\times\overrightarrow{v} \tag3\]</span></p><p>可以使用投影将任意向量分解，如： <span class="math display">\[\overrightarrow{p}=(\overrightarrow{p}\cdot\overrightarrow{u})\overrightarrow{v}+(\overrightarrow{p}\cdot\overrightarrow{v})\overrightarrow{v}+(\overrightarrow{p}\cdot\overrightarrow{w})\overrightarrow{w}\]</span></p></li></ul><hr /><h3 id="matrix">5. Matrix</h3><ul><li><p><strong>矩阵乘法</strong></p><p>设 <span class="math inline">\(A\times B=C\)</span> ，则有 <spanclass="math inline">\(C_{ij}=A_i\cdot B_j\)</span></p></li><li><p><strong>矩阵乘法的性质</strong></p><ul><li>不满足任何交换律</li><li><span class="math inline">\((AB)C = A(BC)\)</span></li><li><span class="math inline">\(A(B+C)=AB+AC\)</span></li><li><span class="math inline">\((A+B)C=AC+BC\)</span></li><li><span class="math inline">\((AB)^\intercal=B^\intercalA^\intercal\)</span></li></ul></li><li><p><strong>矩阵的逆</strong></p><ul><li>单位矩阵是只在对角线上有非零的元素，定义以下单位矩阵：</li></ul><p><span class="math display">\[I_{2\times2}=\begin{pmatrix}  1 &amp; 0 \\  0 &amp; 1 \\\end{pmatrix}\]</span></p><p>​ 则有： <span class="math display">\[AA^{-1}=A^{-1}A=I\]</span></p><ul><li>矩阵的逆的性质： <span class="math display">\[(AB)^{-1}=B^{-1}A^{-1}\]</span></li></ul></li><li><p><strong>将向量的乘积写成矩阵形式</strong></p><ul><li><p>点乘： <span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=\overrightarrow{a}^T\overrightarrow{b}=\begin{pmatrix}x_a &amp; y_a &amp; z_a\end{pmatrix}\begin{pmatrix}x_a \\y_a \\z_a\end{pmatrix}=(x_ax_b+y_ay_b+z_az_b)\]</span></p></li><li><p>叉乘： <span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=A^*b=\begin{pmatrix}    0 &amp; -z_a &amp; y_a \\    z_a &amp; 0 &amp; -x_a \\    -y_a &amp; x_a &amp; 0\end{pmatrix}\begin{pmatrix}    x_b \\    y_b \\    z_b\end{pmatrix}\]</span></p></li></ul></li></ul><p>​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于opencv与pyautogui编写的天翼校园掉线自动重连脚本</title>
    <link href="/2023/10/21/%E5%9F%BA%E4%BA%8Eopencv%E4%B8%8Epyautogui%E7%BC%96%E5%86%99%E7%9A%84%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E6%8E%89%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/10/21/%E5%9F%BA%E4%BA%8Eopencv%E4%B8%8Epyautogui%E7%BC%96%E5%86%99%E7%9A%84%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E6%8E%89%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>因为下载机上的天翼校园隔三岔五就掉线，所以有了这个程序...</p><p>图形化界面需要用到pyqt5和qt-material</p><p>不会写python，乱写，程序倒是还挺稳定，能用 orz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pyautogui<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageGrab<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtWidgets<br><span class="hljs-keyword">from</span> qt_material <span class="hljs-keyword">import</span> apply_stylesheet<br><span class="hljs-keyword">from</span> main_window <span class="hljs-keyword">import</span> Ui_Form<br><br><span class="hljs-comment"># 读取目标图片</span><br>image_message = cv2.imread(<span class="hljs-string">&#x27;message.png&#x27;</span>)<br>image_login = cv2.imread(<span class="hljs-string">&#x27;login.png&#x27;</span>)<br>h1, w1, _ = image_message.shape<br>h2, w2, _ = image_login.shape<br>threshold = <span class="hljs-number">0.6</span><br>run_flag = <span class="hljs-literal">False</span><br>labelEdit = <span class="hljs-literal">None</span><br>errorNum = <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 子线程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">start_threading</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.image = <span class="hljs-literal">None</span><br>        self.run()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, image</span>):<br>        self.image = image<br>        screenshot = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 获取屏幕截图</span><br>        <span class="hljs-comment"># screenshot = ImageGrab.grab()</span><br>        <span class="hljs-keyword">try</span>:<br>            screenshot = ImageGrab.grab()<br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> OSE:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> other_err:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] <span class="hljs-subst">&#123;other_err&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-comment"># screenshot.save(f&#x27;src/&#123;self.get_time()&#125;.png&#x27;)</span><br>        <span class="hljs-keyword">if</span> screenshot <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        screenshot = np.array(screenshot)<br>        <span class="hljs-comment"># 在屏幕截图上搜索目标图片</span><br>        result = cv2.matchTemplate(screenshot, image, cv2.TM_CCOEFF_NORMED)<br>        loc = np.where(result &gt;= threshold)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(loc[<span class="hljs-number">0</span>]) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(loc[<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [loc[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], loc[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_time</span>(<span class="hljs-params">self</span>):<br>        now = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H-%M-%S&#x27;</span>, time.localtime())<br>        <span class="hljs-keyword">return</span> now<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>                <span class="hljs-keyword">global</span> run_flag, errorNum<br><br>                <span class="hljs-keyword">while</span> run_flag:<br>                    now = self.get_time()<br>                    set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nchecking...\nerrorNum: <span class="hljs-subst">&#123;errorNum&#125;</span>&#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\n checking...&#x27;</span>)<br>                    x, y = self.find(image_message)<br><br>                    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                        <span class="hljs-comment"># print(f&#x27; running normally!&#x27;)</span><br>                        <span class="hljs-keyword">pass</span><br>                    <span class="hljs-keyword">elif</span> x &lt; <span class="hljs-number">0</span>:<br>                        set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] 截图失败！&#x27;</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[&#123;self.get_time()&#125;] screen grab failed&#x27;)</span><br>                    <span class="hljs-keyword">else</span>:<br>                        errorNum = errorNum + <span class="hljs-number">1</span><br>                        now = self.get_time()<br>                        set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\n Error! Enable automated scripts...&#x27;</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[&#123;now&#125;]\n Error! Enable automated scripts...&#x27;)</span><br>                        time.sleep(<span class="hljs-number">1</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[message_pos]: &#123;x&#125;,&#123;y&#125;&#x27;)</span><br>                        pyautogui.click(x + w1 // <span class="hljs-number">2</span>, y + h1 // <span class="hljs-number">2</span>)<br>                        time.sleep(<span class="hljs-number">1</span>)<br><br>                        <span class="hljs-keyword">while</span> run_flag:<br>                            x, y = self.find(image_login)<br>                            <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                                now = self.get_time()<br>                                set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nError!\ncant not find login button!\ntrying again...&#x27;</span>)<br>                                <span class="hljs-comment"># print(&quot;Error! can&#x27;t not find login! trying again...&quot;)</span><br>                                time.sleep(<span class="hljs-number">3</span>)<br>                            <span class="hljs-keyword">else</span>:<br>                                time.sleep(<span class="hljs-number">1</span>)<br>                                <span class="hljs-comment"># print(f&#x27;[login_pos]: &#123;x&#125;,&#123;y&#125;&#x27;)</span><br>                                pyautogui.click(x + w2 // <span class="hljs-number">2</span>, y + h2 // <span class="hljs-number">2</span>)<br>                                now = self.get_time()<br>                                set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nSuccess!\nAutomation script completed.&#x27;</span>)<br>                                <span class="hljs-comment"># print(&quot;Success! Automation script completed.&quot;)</span><br>                                <span class="hljs-keyword">break</span><br>                    time.sleep(<span class="hljs-number">3</span>)<br>                time.sleep(<span class="hljs-number">3</span>)<br><br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> OSE:<br>            set_label_text(<span class="hljs-string">f&#x27;系统错误: <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>]系统错误: <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> other_error:<br>            now = self.get_time()<br>            set_label_text(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;now&#125;</span>未知错误\n：<span class="hljs-subst">&#123;other_error&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;now&#125;</span>未知错误\n：<span class="hljs-subst">&#123;other_error&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;STOP&quot;</span>)<br><br><br><span class="hljs-comment"># 主窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span>(QtWidgets.QWidget, Ui_Form):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MainWindow, self).__init__()<br>        self.setupUi(self)<br>        <span class="hljs-keyword">global</span> labelEdit<br>        labelEdit = self.label<br>        apply_stylesheet(app, theme=<span class="hljs-string">&#x27;dark_teal.xml&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click_start_button</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> run_flag<br>        <span class="hljs-keyword">if</span> run_flag:<br>            run_flag = <span class="hljs-literal">False</span><br>            self.startButton.setText(<span class="hljs-string">&quot;RESTART&quot;</span>)<br>            self.label.setText(<span class="hljs-string">&quot;Click button to start.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            run_flag = <span class="hljs-literal">True</span><br>            self.startButton.setText(<span class="hljs-string">&quot;STOP&quot;</span>)<br>            self.label.setText(<span class="hljs-string">&quot;Running...\n&quot;</span>)<br><br><br>thread = threading.Thread(target=start_threading)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_label_text</span>(<span class="hljs-params">message</span>):<br>    labelEdit.setText(message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QtWidgets.QApplication(sys.argv)<br><br>    <span class="hljs-comment"># 开启检测子线程</span><br>    thread.daemon = <span class="hljs-literal">True</span><br>    thread.start()<br><br>    test_ui = MainWindow()<br>    test_ui.show()<br><br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main_window.py</span><br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtCore, QtGui, QtWidgets<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ui_Form</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setupUi</span>(<span class="hljs-params">self, Form</span>):<br>        Form.setObjectName(<span class="hljs-string">&quot;AutoLogin&quot;</span>)<br>        Form.resize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>)<br>        Form.setMinimumSize(QtCore.QSize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>))<br>        Form.setMaximumSize(QtCore.QSize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>))<br>        font = QtGui.QFont()<br>        font.setFamily(<span class="hljs-string">&quot;微软雅黑&quot;</span>)<br>        font.setPointSize(<span class="hljs-number">12</span>)<br>        Form.setFont(font)<br>        Form.setContextMenuPolicy(QtCore.Qt.NoContextMenu)<br>        self.verticalLayoutWidget = QtWidgets.QWidget(Form)<br>        self.verticalLayoutWidget.setGeometry(QtCore.QRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">311</span>, <span class="hljs-number">261</span>))<br>        self.verticalLayoutWidget.setObjectName(<span class="hljs-string">&quot;verticalLayoutWidget&quot;</span>)<br>        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)<br>        self.verticalLayout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        self.verticalLayout.setObjectName(<span class="hljs-string">&quot;verticalLayout&quot;</span>)<br>        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)<br>        self.label.setMinimumSize(QtCore.QSize(<span class="hljs-number">0</span>, <span class="hljs-number">180</span>))<br>        self.label.setAlignment(QtCore.Qt.AlignCenter)<br>        self.label.setObjectName(<span class="hljs-string">&quot;label&quot;</span>)<br>        self.verticalLayout.addWidget(self.label)<br>        spacerItem = QtWidgets.QSpacerItem(<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)<br>        self.verticalLayout.addItem(spacerItem)<br>        self.startButton = QtWidgets.QPushButton(self.verticalLayoutWidget)<br>        self.startButton.setMinimumSize(QtCore.QSize(<span class="hljs-number">130</span>, <span class="hljs-number">0</span>))<br>        self.startButton.setMaximumSize(QtCore.QSize(<span class="hljs-number">150</span>, <span class="hljs-number">16777215</span>))<br>        self.startButton.setObjectName(<span class="hljs-string">&quot;startButton&quot;</span>)<br>        self.verticalLayout.addWidget(self.startButton, <span class="hljs-number">0</span>, QtCore.Qt.AlignHCenter)<br>        spacerItem1 = QtWidgets.QSpacerItem(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)<br>        self.verticalLayout.addItem(spacerItem1)<br><br>        self.retranslateUi(Form)<br>        self.startButton.clicked.connect(Form.click_start_button) <span class="hljs-comment"># type: ignore</span><br>        QtCore.QMetaObject.connectSlotsByName(Form)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">retranslateUi</span>(<span class="hljs-params">self, Form</span>):<br>        _translate = QtCore.QCoreApplication.translate<br>        Form.setWindowTitle(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;AutoLogin&quot;</span>))<br>        self.label.setText(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;Click to Start.&quot;</span>))<br>        self.startButton.setText(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;Start&quot;</span>))<br></code></pre></td></tr></table></figure><p>用到的两张图片分别是天翼校园掉线时的提示窗口上的确认按钮和主程序窗口上的登录按钮，截个图就行。</p>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用WinCDEmu的galgame光盘映像的自动挂载与卸载脚本</title>
    <link href="/2023/10/11/%E4%BD%BF%E7%94%A8WinCDEmu%E7%9A%84galgame%E5%85%89%E7%9B%98%E6%98%A0%E5%83%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/10/11/%E4%BD%BF%E7%94%A8WinCDEmu%E7%9A%84galgame%E5%85%89%E7%9B%98%E6%98%A0%E5%83%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>挺久之前写的一个简单脚本，偶尔还能用上。</p><p>放在游戏目录下，修改变量值。脚本运行后能做到自动挂载光盘和启动游戏程序，检查到游戏进程关闭时自动卸载光盘。</p><p>光盘的挂载用的是<ahref="https://github.com/sysprogs/WinCDEmu">WinCDEmu</a>，把程序batchmnt.exe添加到用户环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><br>::镜像文件路径<br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;cur_path=%CD%&quot;</span><br>::修改这里<br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;iso_filename=DC3WY&quot;</span><br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;gamename=DC3WY&quot;</span><br><br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;iso_filepath=%cur_path%\%iso_filename%.ISO&quot;</span><br><br>::挂载<br><span class="hljs-built_in">echo</span> MOUNT %iso_filepath% !<br>batchmnt <span class="hljs-string">&quot;%iso_filepath%&quot;</span><br>::等待挂载<br>choice /t 1 /d y /n &gt;nul<br><br>::启动游戏<br>%gamename%.EXE<br><br>:start<br>choice /t 2 /d y /n &gt;nul<br>tasklist|find /i <span class="hljs-string">&quot;%gamename%.EXE&quot;</span><br><span class="hljs-keyword">if</span> %errorlevel% NEQ 0 ( <br>                <span class="hljs-built_in">echo</span> The %gamename% closes !<br>    goto end<br>)<br>goto start  （循环）<br><br>:end<br>batchmnt /unmount <span class="hljs-string">&quot;%iso_filepath%&quot;</span><br><br><span class="hljs-built_in">echo</span> UNMOUNTED %iso_filepath% !<br><br>choice /t 2 /d y /n &gt;nul<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
