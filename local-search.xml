<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Games101 - Lecture 14 Ray Tracing 2</title>
    <link href="/2024/02/15/Games101-Lecture-14-Ray-Tracing-2/"/>
    <url>/2024/02/15/Games101-Lecture-14-Ray-Tracing-2/</url>
    
    <content type="html"><![CDATA[<h1 id="ray-tracing-2">Ray Tracing 2</h1><h3 id="uniform-spatial-partitions-grids">1. Uniform Spatial Partitions(Grids)</h3><p>均匀空间划分是 AABB 的一种加速方法。</p><ul><li>找到包围盒后，用网格将包围盒划分为许多小盒子，并找到哪些盒子会与物体表面有交点。</li><li>再按光线射入的顺序遍历盒子，遇到与物体有交点的盒子时，遍历盒子内检查光线是否与物体有交点。</li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240208142429128.png" style="zoom: 67%;" /></p><p>相比不优化的方法，我们只需要多做几次光线与盒子的求交，就可以减少光线与物体的求交次数。由于光线与物体求交的复杂度要远大于与盒子求交的复杂度，效率可以得到很好的提升。</p><p>（根据经验，当划分出盒子的数量是包围盒中物体数量的 27倍左右时效率最大化）</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215192812813.png"alt="物体分布不均的场景" /><figcaption aria-hidden="true">物体分布不均的场景</figcaption></figure><p>当场景空间中的物体分布均匀时，均匀空间划分的效果比较好。物体分布不均匀时，均匀空间划分后将会划分出许多空的盒子，划分这些盒子所消耗的计算量是无意义的。这被称为"Teapot in a stadium" 问题。</p><h3 id="spatial-partitions">2. Spatial Partitions</h3><p>空间划分是在均匀空间划分的基础上，针对其缺点（空间中物体分布不均匀时效率降低）修改的一种方法。</p><p>说白了就是在“空”的地方，不再用同样大小的网格进行划分，而是使用其他的划分结构，能够将这些“空”的地方用少量的网格划分出来。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215163643878.png" /></p><ul><li><p>N叉树：当划分得到的一个盒子足够小或它已经是空的之后，停止对这个盒子进行划分，这样就避免了分出更多小的空盒子。N叉树有个缺点，在线段中它是二叉树，在 N 维时会进化为 <spanclass="math inline">\(2^N\)</span>叉树，变成一个很复杂的数据结构，因此人们不喜欢用这个划分结构。</p></li><li><p>BSP树：二分包围盒，每次在一个方向上根据二分结果划分。缺点是划分后的网格不与轴平行，以及在高维情况下难以划分与计算。</p></li><li><p><strong>KD树</strong>：按照空间中多个坐标轴的方向，交替方向对网格进行划分，每次划分每个盒子只会被划分为两半（划分位置不一定要在中间），作为当前盒子的两个子节点，所以KD 树是一个二叉树，且空间中物体信息只会存储在叶子节点上。</p></li></ul><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215171244960.png" /></p><p>在做光线追踪之前先建立好加速结构，那么 KD树是如何帮助我们做到加速的呢？</p><p>一束光线射入包围盒就表示它会与 KD树的根节点相交，可以从根节点出发向下遍历 KD树。遍历到根节点就判断它是否与光线相交，否则停止在该方向上遍历。遍历到叶子节点就判断它是否与光线相交，并且该节点中的物体是否与光线相交，是则找到光线打中的点并停止遍历。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215173838906.png" /></p><p>实际上的 KD树仍存在不好的问题与性质，例如如何判断三角形面是否在某个叶子节点中？如果一个物体或三角形面同时存在两个不同的叶子节点中时，应该如何存储？这些问题的解决方法较难实现，所以渐渐地KD 树已不再是一种被广泛使用的方法。</p><h3 id="bounding-volume-hierarchy-bvh">3. Bounding Volume Hierarchy(BVH)</h3><p>BVH 解决了空间划分中存在的不好的问题，得到了很广泛的应用。</p><p>首先，BVH不在空间上进行划分，而是对空间中的物体进行划分。假设我有如下一些物体，先用一个最大的包围盒将其包括起来：<imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215181027897.png" /></p><p>再按某个方向，将着一些三角形分为两部分并分别计算这两部分的新的包围盒。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215181209391.png" /></p><p>可以发现新的包围盒间有可能存在一部分重叠，为了提高效率，应该注意划分方式使得重叠部分面积尽可能小。再对新的包围盒划分，直到划分后的包围盒满足一定条件。同样的，只会在叶子节点存储物体信息。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215181549829.png" /></p><p>通过如此划分之后，我们可以明确地知道哪个三角形会在哪个包围盒里，并且任意一个三角形都只会出现在一个包围盒中，解决了KD 树出现的问题。</p><p>划分物体时有一些技巧：</p><ul><li>始终选择节点中最长的边的方向进行划分。</li></ul><p>注意划分方向可以保证划分后的包围盒各边平衡。</p><ul><li>在中间对象的位置分割节点。</li></ul><p>注意使划分两边的三角形数量相近可以保证二叉树平衡，快速选择算法可以在O(n) 的复杂度解决 Top K 问题。</p><ul><li>在包围盒中三角形数量少时停止划分（e.g. 5)</li></ul><p>BVH 的实际应用与 KD Tree 差不多，都是在二叉树中遍历：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240215192628979.png"alt="伪代码" /><figcaption aria-hidden="true">伪代码</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture 13 Ray Tracing 1</title>
    <link href="/2024/02/06/Games101-Lecture-13-Ray-Tracing-1/"/>
    <url>/2024/02/06/Games101-Lecture-13-Ray-Tracing-1/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Alice01_MoeSR_x4_jp_Illustration-fix1-d-small.png" /></p><h1 id="ray-tracing">Ray Tracing</h1><h3 id="why-ray-tracing">1. Why Ray Tracing</h3><p>光栅化是一种快速近似的成像方法，其准确性较低，局限性较大。</p><p>例如，光栅化难以生成高质量的软阴影、高光反射与间接光照等等效果。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240204154857213.png" /></p><p><strong>光栅化速度快，但质量较低。光线追踪则相反，质量很高，但是速度很慢。</strong></p><p>所以，光栅化用于进行实时的渲染（游戏等），而光线追踪用于离线的渲染（电影等）。</p><h3 id="light-rays">2. Light Rays</h3><p>在开始光线追踪之前，我们对光线定义：</p><ul><li>光线只会沿直线传播；</li><li>光线之间彼此交叉时不会产生“碰撞”；</li><li>光线从光源经过传播到达眼睛，且<strong>光路可逆</strong>；</li></ul><h3 id="ray-casting">3. Ray Casting</h3><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206154712509.png" style="zoom:80%;" /></p><p>首先，我们假设场景中的观察点与光源都是一个点，且光线打到物体上时会发生完美的折射或反射。</p><p>利用光路可逆这一特点，进行光线投射时，从观察点出发，经过成像平面上的像素点连一条线打出一根光线（eyeray），光线一定会打到场景中的某个位置（最近的一个交点），或不与任何物体相交。根据光线与场景相交的位置就能知道成像平面上这个像素点观察到的是场景中的哪个位置。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206155747412.png" /></p><p>之后，我们再从观察到的点出发，向光源打出一条光线（shadowray），如果这条光线中间没有任何物体的遮挡，那该点就不在阴影中。这样，我们就有了该点的法线、入射方向与出射方向，可以计算该点的着色并写入对应的像素。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206160411257.png"alt="image-20240206160411257" /><figcaption aria-hidden="true">image-20240206160411257</figcaption></figure><p>事实上，以上只考虑光线反射一次的情况，并不能反映准确的效果。</p><h3 id="recursive-whitted-style-ray-tracing">4. Recursive(Whitted-Style) Ray Tracing</h3><p>类似的，我们从观察点出发经过像素点打出一条光线（primaryray)，当光线与物体相交时，根据交点处物体的性质，我们不仅是考虑由于镜面反射，光线在交点处发生的反射光线（Reflectedray），还可能要考虑由于镜面透射，光线在交点处发生的折射光线（Refractedrays）。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206164503434.png" /></p><p>也就是说，在该方法中只要光线能够被正确的计算，你可以无限的传播光线。</p><p>着色时，我们需要对所有发生反射或是折射的点进行着色，所有点的着色结果会被累加到像素中。当然着色时要考虑其可见性与能量损失，以保证结果的正确性。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206165339918.png" /></p><p>各种光线的分类：</p><ul><li>从相机出发的第一根光线称为 primary ray；</li><li>在发生一次光线的反射或折射后的，发生的光线称为 secondary ray；</li><li>用于判定可见性的，向光源的连线称为 shadow ray；</li></ul><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206165848962.png"alt="早期的 Whitted-Style 光线追踪效果" /><figcaption aria-hidden="true">早期的 Whitted-Style光线追踪效果</figcaption></figure><h3 id="equation">5. Equation</h3><h4 id="ray-equation">5.1 Ray Equation</h4><p>光线（射线）在数学上由其原点和方向向量定义。</p><p>例如:<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206171807282.png" style="zoom:50%;" /></p><p>光线方程： <span class="math display">\[r(t)=o+td,\;0\leqslant t&lt;\infty\]</span> 其中 <span class="math inline">\(o\)</span> 表示原点，<spanclass="math inline">\(t\)</span> 表示“时间”，<spanclass="math inline">\(d\)</span> 表示方向。</p><h4 id="plane-equation">5.2 Plane Equation</h4><p>平面在数学上由法线方向与平面上的一个点定义。</p><p>例如：<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240206181235044.png" style="zoom:50%;" /></p><p>任意一点 <span class="math inline">\(p\)</span> 与平面上 <spanclass="math inline">\(p&#39;\)</span>的连线与法线垂直，则该点在平面上，<span class="math inline">\(p\)</span>满足： <span class="math display">\[(p-p&#39;)\cdot N=0\]</span> 在三维中将其展开，得平面方程： <span class="math display">\[ax+by+cz+d=0\]</span></p><h3 id="ray-surface-intersection">6. Ray-Surface Intersection</h3><h4 id="ray-intersection-with-implicit-surface">6.1 Ray Intersectionwith Implicit Surface</h4><p>假设要求光线与球表面的交点，二者在数学上的定义分别是：</p><ul><li>光线：<span class="math inline">\(r(t)=o+td\;,\;(0\leqslantt&lt;\infty)\)</span></li><li>球面上的点 <span class="math inline">\(p\)</span>：<spanclass="math inline">\((p-c)^2-R^2=0\)</span></li></ul><p>相交时，交点既在光线上，又在球表面上，所以有 <spanclass="math inline">\(p=o+td\)</span>，即满足 <spanclass="math inline">\((o+td-c)^2-R^2=0\)</span> 时相交。</p><p>推广到一般性的隐式表面的求交，当</p><ul><li>隐式表面上点 <span class="math inline">\(p\)</span>：<spanclass="math inline">\(f(p)=0\)</span></li></ul><p>代入光线方程得 <spanclass="math inline">\(f(o+td)=0\)</span>，解出正实数 <spanclass="math inline">\(t\)</span>，再代入光线方程得到交点。</p><h4 id="ray-intersection-with-triangle-mesh">6.2 Ray Intersection withTriangle Mesh</h4><p>解决光线与三角形面求交问题，我们可以将问题分解：</p><ul><li>光线与三角形所在平面求交</li><li>判断交点是否在三角形内</li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240207115050005.png" style="zoom:80%;" /></p><ul><li>光线：<span class="math inline">\(r(t)=o+td\;,\;(0\leqslantt&lt;\infty)\)</span></li><li>平面：<span class="math inline">\((p-p&#39;)\cdot N=0\)</span></li></ul><p>当光线与平面相交时，交点既在光线上，又在平面上。</p><p>设 <span class="math inline">\(p=r(t)\)</span> ，得 <spanclass="math inline">\((p-p&#39;)\cdot N=(o+td-p&#39;)\cdotN=0\)</span></p><p>化简得： <span class="math display">\[t=\frac{(p&#39;-o)\cdot N}{d\cdot N},\;0\leqslant t&lt;\infty\]</span> 解出 <span class="math inline">\(t\)</span>后得到交点，再判断交点是否在三角形内。</p><p>如何判断交点在三角形内详见本课程第二节<ahref="https://memo2586.github.io/2023/11/22/Games101-Lecture-02-Review-of-Linear-Algebra/#vector-multiplication-cross-product">向量叉乘</a>的内容。</p><p>在实际进行光线追踪时，如果我们要通过遍历所有三角形面去判断这条光线与哪个三角形面相交，那复杂度是相当恐怖的。我们还需要一些优化。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240207174709253.png" /></p><h4 id="möller-trumbore-algorithm">6.3 Möller Trumbore Algorithm</h4><p><ahref="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection.html">MT算法</a>是一种快速求光线与三角形面交点的算法。</p><p>光线与三角形面如果有交点，那么必定在三角形面上。我们知道，三角形面上任意一点都可以表示为其三个顶点的线性组合，那么可以得到：<span class="math display">\[\overrightarrow{O}+t\overrightarrow{D}=(1-b_1-b_2)\overrightarrow{P_0}+b_1\overrightarrow{P_1}+b_2\overrightarrow{P_2}\]</span> 在三维中，用克莱姆法则解这个线性方程组： <spanclass="math display">\[\begin{bmatrix}t \\ b_1 \\ b_2\end{bmatrix} =\frac{1}{\overrightarrow{S_1}\cdot \overrightarrow{E_1}}\begin{bmatrix}\overrightarrow{S_2}\cdot \overrightarrow{E_2} \\\overrightarrow{S_1}\cdot \overrightarrow{S} \\\overrightarrow{S_2}\cdot \overrightarrow{D} \\\end{bmatrix}\]</span> 其中， <span class="math display">\[\begin{gather*}\overrightarrow{E_1}=\overrightarrow{P_1}-\overrightarrow{P_0} \\\overrightarrow{E_2}=\overrightarrow{P_2}-\overrightarrow{P_0} \\\overrightarrow{S}=\overrightarrow{O}-\overrightarrow{P_0} \\\overrightarrow{S_1}=\overrightarrow{D}\times\overrightarrow{E_2} \\\overrightarrow{S_2}=\overrightarrow{S}\times\overrightarrow{E_1}\end{gather*}\]</span></p><h3 id="bounding-volumes">7. Bounding Volumes</h3><p>用一个简单体积绑定复杂物体，让物体全部包围在其中，称为包围盒。当光线不穿过包围盒时，那这条光线肯定与物体没有交点。</p><p>包围盒可以理解为三对不同平面的交集，为了简化计算，常使用三对分别与三个坐标轴平行的平面定义的包围盒，称为轴对齐包围盒（Axis-AlignedBounding Box, AABB）。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240207175932161.png" style="zoom: 50%;" /></p><p>那要如何判断光线是否穿过包围盒？</p><p>如果一个点在包围盒中，他应该满足同时在任意一对平面之间。让我们先把问题降级到二维中，在x 轴方向的一对平面与 y方向的一堆平面，分别得出光线从进入一堆平面之间的时间 <spanclass="math inline">\(t_{min}\)</span> 和离开的时间 <spanclass="math inline">\(t_{max}\)</span>（t可能为负）。那么，光线穿过包围盒花费的时间就是这两个时间段的交集，即<span class="math display">\[t_{enter}=\max{(t_{min})},\;t_{exit}=\min{(t_{max})}\]</span> 如果 <spanclass="math inline">\(t_{enter}&lt;t_{exit}\)</span>，我们就认为光线在包围盒中停留了一段时间。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240207204149311.png" /></p><p>再考虑时间 t 为负数的情况：</p><ul><li><span class="math inline">\(t_{enter}\)</span>为负数，即光线的起点在包围盒中，光线一定穿过包围盒。</li><li><span class="math inline">\(t_{exit}\)</span>为负数，包围盒在光线方向的反方向，光线一定不穿过包围盒。</li></ul><p>在三维情况下，该方法同样适用。综上，判断是否在包围盒中需要满足：<span class="math display">\[t_{enter}&lt;t_{exit}\;\&amp;\&amp;\;t_{exit}\geq0\]</span></p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture 12.5 Shadows</title>
    <link href="/2024/02/02/Games101-Lecture-12-5-Shadows/"/>
    <url>/2024/02/02/Games101-Lecture-12-5-Shadows/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/FGKD01B%20(realesrgan-x4plus-anime%20x2).png" /></p><h2 id="shadow-mapping">Shadow Mapping</h2><p>模型在实际上存在遮挡关系，被遮挡的地方会产生阴影，之前学习的着色模型并未考虑到这一点。</p><p>Shadow Mapping是一种图像空间算法，是一种在计算阴影时不需要了解场景几何结构的方法。</p><p>Shadow Map理论上只能<strong>应用于点光源场景与渲染硬阴影</strong>，但不妨碍 ShadowMap 成为主流的技术。</p><p>该算法的主要思路是：<strong>不在阴影中的点，必须同时被光源和相机所看到</strong>。</p><h3 id="shadow-mapping-的步骤">Shadow Mapping 的步骤</h3><ol type="1"><li><p>从光源对整个场景做一个光栅化，不做着色，只记录下深度信息；</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202170456020.png" style="zoom: 67%;" /></p></li><li><p>从摄像机视角做光栅化，任何一个点只要将其投影到之前从光源记录下的深度图中，如果从摄像机到该点的深度信息与从光源到该点的深度信息一致，那么该点不在阴影中；</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202171311702.png" style="zoom:67%;" /></p><p>如果从摄像机到该点的深度信息与从光源到该点的深度信息不一致，那么该点在阴影中；</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202171553857.png" style="zoom:67%;" /></p></li></ol><h3 id="shadow-mapping-的问题">Shadow Mapping 的问题</h3><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202171946800.png" /></p><p>从光源出发，可以得到像这样一个深度图：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202172212285.png" style="zoom:67%;" /></p><p>当我从实际的相机看到的点，再将其投影到上面那张深度图时：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202172520434.png" style="zoom:80%;" /></p><p>可以观察到存在走样与明显错误。</p><p>为什么会出现错误？因为几何在实际的场景中都是以浮点数计算的，那就容易出现精度问题，要做到“是否一致”这个判定条件本身就很困难。如果更改为判断大小或者添加误差范围，可以改善问题。</p><p>另外，如果 Shadow Map本身的分辨率太低，而场景渲染时使用的分辨率太高，自然就会产生走样（游戏中的阴影质量设置大部分是对Shadow Map 的分辨率作调整）。</p><h3 id="软阴影soft-shadows">软阴影（Soft Shadows）</h3><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240202174939857.png" /></p><p>软阴影的边缘频率低，有明显的过度，且越靠近物体的根部阴影就越“硬”。</p><p>软阴影就是物理上的半影，是指由于光源的扩散或光线经过不完全遮挡的物体表面而产生的较为柔和的阴影效果。当光源足够大时，从光源的不同位置向某点的遮挡情况不同。也就是说，从物体表面出发可以看到的光源大小不同，可以看到的光源越小，该点的阴影就越清晰。</p><p>从不产生阴影的点逐渐向朝向光源的物体背面移动，可以看到的光源大小是逐渐变小的，也就产生了自然柔和的，边缘不清晰的阴影效果。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>Shadows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture 12 Geometry 3</title>
    <link href="/2024/01/31/Games101-Lecture-12-Geometry-3/"/>
    <url>/2024/01/31/Games101-Lecture-12-Geometry-3/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/FGRN13A%20(realesrgan-x4plus-anime%20x2).png" /></p><h1 id="geometry-processing">Geometry Processing</h1><h3 id="mesh-subdivision">1. Mesh subdivision</h3><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240131172124465.png" /></p><h4 id="表面细分的规则">表面细分的规则</h4><p>表面细分可不仅仅是将一个多边形划分为更多的多边形这么简单，还要让划分后的模型表面更加光滑。</p><p>可以说，表面细分的步骤分为两步：</p><ul><li>创建更多的三角形（顶点）</li><li>调整他们的位置</li></ul><h4 id="loop-subdivision">Loop Subdivision</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Loop 方法使用发明者 Charles Loop 的姓命名<br>绝不是该方法与循环有什么关系~<br></code></pre></td></tr></table></figure><ul><li><p>将三角形每条边的中点两两相连，将一个三角形划分成四个三角形 <imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240131174211575.png" /></p></li><li><p>根据权重改变顶点的位置（新旧顶点的更新方式不同）</p><ul><li><p>对于新的顶点：</p><p>考虑两个相邻的三角形，一般来说，旧的三角形的边都会与相邻三角形共享（边界等特殊情况除外），而新的顶点又都定义在这些边的中点上。所以，新的顶点都会与相邻另一个三角形共享。</p><p>我们要做的是，找到新的顶点所在的共享边上的两个顶点，与另外的两个顶点的坐标，按照一定的权重对这些坐标取平均，用来决定这个新的顶点的坐标。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240131180046059.png" style="zoom: 50%;" /></p><p>比如上图的白点 P，它所在的共享边的两端端点为 A 与B，另外的两个顶点坐标为 C 与 D，可以按照以下方法计算该点的坐标： <spanclass="math display">\[P=3/8(A+B)+1/8(C+D)\]</span></p></li><li><p>对于旧的顶点：</p><p>与新的顶点相似，旧的顶点同样考虑采用临近点的加权平均值作为新的坐标。当此时，权重是根据顶点的度数决定的。</p><p>一个顶点的度数越低，那么该顶点对模型的整体外观中起到的决定性作用越强，例如一个尖锐的边缘、拐角或者是模型的凹凸点。那么这些点的原始坐标所占的权重旧越大，反之原始坐标所占的权重旧就越小。</p><p>综上，定义两个变量：</p><ul><li><p>n：顶点的度数</p></li><li><p>u：与顶点度数相关的一个常数，可以取作 <spanclass="math display">\[u =\begin{cases}    3/16 &amp; \text{if } n = 0 \\    3/(8n) &amp; \text{otherwise}\end{cases}\]</span></p></li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240131204621089.png" style="zoom:50%;" /></p></li></ul><p>如上图的度数为 6 的白点 P，它临近的所有点的和为S，那么计算新的坐标为： <span class="math display">\[(1-nu)*P+u*S\]</span></p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240131210604843.png"alt="Loop Subdivision" /><figcaption aria-hidden="true">Loop Subdivision</figcaption></figure><p>Loop Subdivision 只有在多边形全是三角形的情况下才能工作。</p><h4 id="catmull-clark-subdivision">Catmull-Clark Subdivision</h4><p>在学习 Catmull-Clark Subdivision 之前，定义两个概念：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201151925127.png" style="zoom: 50%;" /></p><ol type="1"><li><p>Non-quad face：非四边形面</p></li><li><p>Extraordinary vertex：奇异点，度数不为 4 的点</p></li></ol><ul><li><p>表面细分的第一步自然是增加顶点的数量，取多边形面的每条边的中点，与多边形面内部的一个中心点，再把边上的中点与面上的中心点都连起来：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201153757845.png" style="zoom:50%;" /></p><p>在划分非四边形面时，由于其中心点要连接其边数多的点，所以它会变成一个奇异点，且非四边形面会被划分成多个四边形面。</p><p>也就是说在一次 Catmull-Clark Subdivision中，通过引入与非四边形面相同数量的奇异点，能够将所有面划分成四边形面。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201155213466.png" style="zoom:50%;" alt="第二次细分后奇异点数量不再增加"></p></li><li><p>对顶点坐标进行更新，该方法把顶点分为三类，按照以下规则更新：</p><ul><li><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201162053717.png" style="zoom: 67%;" /><span class="math display">\[f = \frac{v_1+v_2+v_3+v_4}{4}\]</span></p></li><li><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201162248573.png" style="zoom:67%;" /><span class="math display">\[e=\frac{v_1+v_2+f_1+f_2}{4}\]</span></p></li><li><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201162642475.png" style="zoom:67%;" /><span class="math display">\[v=\frac{f_1+f_2+f_3+f_4+2(m_1+m_2+m_3+m_4)+4p}{16}\]</span></p></li></ul></li></ul><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201164342042.png" /></p><hr /><h3 id="mesh-simplification">2. Mesh Simplification</h3><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201165257261.png" /></p><h4 id="edge-collapsing边坍缩">Edge Collapsing（边坍缩）</h4><p>边坍缩：找到一条边，把这条边两端的顶点合为一个顶点。自然的这条边就消失了。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201170102345.png" style="zoom: 50%;" /></p><h4 id="quadric-error-metrics二次误差度量">Quadric ErrorMetrics（二次误差度量）</h4><p>在边坍缩后，我如何决定剩下的顶点的位置，使得边坍缩对模型外观的影响最小？</p><p>如果只是简单地对该坍缩点有关系的面进行求和取平均，那么通常不能得到一个很好的效果。此时我们要用到二次误差度量，它与机器学习中的L2 距离十分相似。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201170807947.png" style="zoom:67%;" /></p><p>找到一个位置，使得在该位置上坍缩点到原本的面的距离的平方和最小。</p><p>那么对于一个模型，我们可以计算出其所有边坍缩后产生的二次误差度量后，对这些二次误差度量进行排序，然后从最小花费开始进行边坍缩？</p><p>按照这种方法会有个小问题：坍缩一条边后，与这条边相邻的边的位置会产生变化，其二次误差度量也会跟着变化。我们无法保证经过变化后，当前排序的最小花费依旧正确。</p><p>为此我们需要用小根堆，既可以快速查询，也可以动态更新。</p><p>在上述方法中，我们通过不断求出局部的最优解，去试图找到全局的一个最优解，也就是典型的贪心算法，并不能保证全局的最优解（但是够用）。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240201175126362.png" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>几何</tag>
      
      <tag>几何处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - 作业4</title>
    <link href="/2024/01/29/Games101-%E4%BD%9C%E4%B8%9A4/"/>
    <url>/2024/01/29/Games101-%E4%BD%9C%E4%B8%9A4/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/shion6-small.png" /></p><h1 id="作业-4bézier-曲线">作业 4：Bézier 曲线</h1><h3 id="基本">基本</h3><p>来自作业的文档说明：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">De Casteljau 算法说明如下：<br>1. 考虑一个 p0, p1, ... pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。<br>2. 用 t : (1 − t) 的比例细分每个线段，并找到该分割点。<br>3. 得到的分割点作为新的控制点序列，新序列的长度会减少一。<br>4. 如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。<br>   使用 [0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。<br></code></pre></td></tr></table></figure><p><ahref="https://memo2586.github.io/2024/01/26/Games101-Lecture-11-Geometry-2/#%E7%94%BB%E5%87%BA%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BFde-casteljau-%E7%AE%97%E6%B3%95">DeCasteljau 算法的详细步骤</a>。</p><p>根据 <ahref="https://memo2586.github.io/2024/01/26/Games101-Lecture-11-Geometry-2/#de-casteljau-%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%A3%E6%95%B0%E8%A1%A8%E7%A4%BA">DeCasteljau 的代数表示</a>，第 2 步中分割点的坐标计算方法为： <spanclass="math display">\[b_i^j(t) = (1-t)b_i + tb_j\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><br>std::vector&lt;cv::Point2f&gt; control_points;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouse_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> event, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> flags, <span class="hljs-type">void</span> *userdata)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (event == cv::EVENT_LBUTTONDOWN &amp;&amp; control_points.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Left button of the mouse is clicked - position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span><br>        &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        control_points.<span class="hljs-built_in">emplace_back</span>(x, y);<br>    &#125;     <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">naive_bezier</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;p_0 = points[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">auto</span> &amp;p_1 = points[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">auto</span> &amp;p_2 = points[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">auto</span> &amp;p_3 = points[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">0.0</span>; t &lt;= <span class="hljs-number">1.0</span>; t += <span class="hljs-number">0.001</span>) <br>    &#123;<br>        <span class="hljs-keyword">auto</span> point = std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - t, <span class="hljs-number">3</span>) * p_0 + <span class="hljs-number">3</span> * t * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - t, <span class="hljs-number">2</span>) * p_1 +<br>                 <span class="hljs-number">3</span> * std::<span class="hljs-built_in">pow</span>(t, <span class="hljs-number">2</span>) * (<span class="hljs-number">1</span> - t) * p_2 + std::<span class="hljs-built_in">pow</span>(t, <span class="hljs-number">3</span>) * p_3;<br><br>        window.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">cv::Point2f <span class="hljs-title">recursive_bezier</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="hljs-type">float</span> t)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span><br>    <span class="hljs-keyword">if</span>(control_points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> control_points[<span class="hljs-number">0</span>];<br><br>    std::vector&lt;cv::Point2f&gt; new_control_points;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; control_points.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        cv::Point2f u = control_points[i - <span class="hljs-number">1</span>], v = control_points[i];<br>        cv::Point2f b = (<span class="hljs-number">1.f</span> - t) * u + t * v;<br>        new_control_points.<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursive_bezier</span>(new_control_points, t);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bezier</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span><br>    <span class="hljs-comment">// recursive Bezier algorithm.</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> t = <span class="hljs-number">0</span>; t &lt;= <span class="hljs-number">1.f</span>; t += <span class="hljs-number">.001</span>)&#123;<br>        cv::Point2f point = <span class="hljs-built_in">recursive_bezier</span>(control_points, t);<br>        window.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x) += cv::<span class="hljs-built_in">Vec3b</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cv::Mat window = cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>, CV_8UC3, cv::<span class="hljs-built_in">Scalar</span>(<span class="hljs-number">0</span>));<br>    cv::<span class="hljs-built_in">cvtColor</span>(window, window, cv::COLOR_BGR2RGB);<br>    cv::<span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;Bezier Curve&quot;</span>, cv::WINDOW_AUTOSIZE);<br><br>    cv::<span class="hljs-built_in">setMouseCallback</span>(<span class="hljs-string">&quot;Bezier Curve&quot;</span>, mouse_handler, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (key != <span class="hljs-number">27</span>) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;point : control_points) <br>        &#123;<br>            cv::<span class="hljs-built_in">circle</span>(window, point, <span class="hljs-number">3</span>, &#123;<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;, <span class="hljs-number">3</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (control_points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>) <br>        &#123;<br>            <span class="hljs-built_in">naive_bezier</span>(control_points, window);<br>            <span class="hljs-built_in">bezier</span>(control_points, window);<br><br>            cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Bezier Curve&quot;</span>, window);<br>            cv::<span class="hljs-built_in">imwrite</span>(<span class="hljs-string">&quot;my_bezier_curve.png&quot;</span>, window);<br>            key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Bezier Curve&quot;</span>, window);<br>        key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">20</span>);<br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240129174030303.png"alt="绘制绿色曲线" /><figcaption aria-hidden="true">绘制绿色曲线</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240129174459712.png"alt="绘制 7 阶贝塞尔曲线" /><figcaption aria-hidden="true">绘制 7 阶贝塞尔曲线</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240129173618148.png"alt="同时调用 naive_bezier 和 bezier 函数" /><figcaption aria-hidden="true">同时调用 naive_bezier 和 bezier函数</figcaption></figure><h3 id="进阶">进阶</h3><p>来自作业的文档说明</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">实现对 Bézier 曲线的反走样。(对于一个曲线上的点，不只把它对应于一个像素，你需要根据到像素中心的距离来考虑与它相邻的像素的颜色。)<br></code></pre></td></tr></table></figure><p>对曲线上每一个点，考虑根据距离因数对其临近 4 个像素点进行着色。</p><p>对该点的 x 与 y 的坐标值四舍五入一下，可以得到距离该点最近的 4x4像素的中心点，再从该中心点出发遍历 4x4 范围的像素中心点。</p><p>假设距离为 d ，且 d 的最大值为 <spanclass="math inline">\(2\sqrt{2}\)</span>，该曲线颜色为c，可以计算任意像素点颜色值为： <span class="math display">\[col=max(0,c-\frac{255d}{2\sqrt{2}})\]</span> 最后，像素点颜色值取原本的颜色值与 col间的最大值，避免后一个点的临近像素与前一个点重合，覆盖掉前一个点的颜色值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-type">const</span> cv::Point2f &amp;point, cv::Mat &amp;window, cv::Vec3b color)</span></span>&#123;<br>    <span class="hljs-comment">// 最近的 4 x 4 中心点</span><br>    <span class="hljs-type">float</span> cnter_x = std::<span class="hljs-built_in">floor</span>(point.x + <span class="hljs-number">0.5</span>), cnter_y = std::<span class="hljs-built_in">floor</span>(point.y + <span class="hljs-number">0.5</span>);<br><br>    <span class="hljs-type">float</span> mo[][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>        <span class="hljs-comment">// 临近像素的中心点</span><br>        <span class="hljs-type">float</span> x = cnter_x + mo[i][<span class="hljs-number">0</span>], y = cnter_y + mo[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 该像素中心点到原来曲线上的点的距离</span><br>        <span class="hljs-type">float</span> dis = std::<span class="hljs-built_in">sqrt</span>((x - point.x) * (x - point.x) + (y - point.y) * (y - point.y));<br>        <span class="hljs-comment">// 从距离来考虑颜色</span><br>        <span class="hljs-type">float</span> col_ratio = <span class="hljs-number">255.f</span> * dis / std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>            <span class="hljs-comment">// 该像素的颜色值</span><br>            <span class="hljs-type">float</span> col = std::<span class="hljs-built_in">max</span>(color[j] - col_ratio, <span class="hljs-number">0.f</span>);<br>            <span class="hljs-comment">// 取最大值，避免后一个点的临近像素与前一个点重合，覆盖掉前一个点的颜色值</span><br>            window.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(y, x)[j] = std::<span class="hljs-built_in">max</span>(window.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(x, y)[j], (uchar)col);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240130173426301.png"alt="无反走样" /><figcaption aria-hidden="true">无反走样</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240130173354122.png"alt="反走样" /><figcaption aria-hidden="true">反走样</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2024-01-30_17-46-16.png"alt="无反走样" /><figcaption aria-hidden="true">无反走样</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2024-01-30_17-47-02.png"alt="反走样" /><figcaption aria-hidden="true">反走样</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>反走样</tag>
      
      <tag>Bézier曲线</tag>
      
      <tag>代码实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture11 Geometry 2</title>
    <link href="/2024/01/26/Games101-Lecture-11-Geometry-2/"/>
    <url>/2024/01/26/Games101-Lecture-11-Geometry-2/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/imocyo01-small.png" /></p><h1 id="geometry-2-curves-and-surfaces">Geometry 2 (Curves andSurfaces)</h1><h2 id="more-explicit-representations">1. More ExplicitRepresentations</h2><h3 id="point-cloud-explicit">1.1 Point Cloud (Explicit)</h3><p>点云，一种最简单的几何的显示表示方式。</p><h4 id="什么是点云">什么是点云？</h4><p>点云就是一个几何物体的表面的点的集合。只要集合中的点在三维空间中的密度足够小，我们就可以将其看作一个连续的表面。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126161152602.png" style="zoom: 67%;" /></p><p>理论上只要点云中点的密度足够小，就可以表示三位空间中的任何几何。</p><p>点云在计算机图形中的性能不好，因此也不常用，多用于一些扫描得到的原始模型。</p><h3 id="polygon-mesh-explicit">1.2 Polygon Mesh (Explicit)</h3><p>多边形面，计算机图形学中使用最广泛的一种显示表示方法。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126161302091.png" style="zoom: 67%;" /></p><p>将几何表面进行划分成许多个多边形面的组合，大多是三角形或是四边形面，最后使用这些多边形面的组合近似表示原来的几何表面。</p><h2 id="bézier-curves">2. Bézier Curves</h2><h3 id="什么是贝塞尔曲线">2.1 什么是贝塞尔曲线？</h3><p>贝塞尔曲线用一系列的控制点去定义某一个曲线，是一种显示的几何表示方法。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126162202171.png" style="zoom: 50%;" /></p><p>如图，通过定义四个（可以是任意个数）控制点 <spanclass="math inline">\(P_{0..3}\)</span>，我们规定曲线的起始切线与结束切线必须与<span class="math inline">\(P_0P_1\)</span> 与 <spanclass="math inline">\(P_2P_3\)</span> 相同。</p><p>这样将可以得到唯一的一条曲线，可以看出，曲线不一定会经过控制点：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126162732744.png" style="zoom:50%;" /></p><h3 id="画出贝塞尔曲线de-casteljau-算法">2.1 画出贝塞尔曲线——deCasteljau 算法</h3><p>考虑三个控制点（二次贝塞尔曲线）：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126163302375.png" style="zoom: 80%;" /></p><p>假设我在时间 0 从 <span class="math inline">\(b_0\)</span> 出发，时间1 时到达 <span class="math inline">\(b_2\)</span>，在这段时间内我路过的点的集合就是所求曲线。</p><p>那么定义一个时间 t ，我只要能知道任意 t时刻我的位置，就能得到这条曲线了。</p><p>de Casteljau 算法可以找到任意 t 时刻的位置。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126165049622.png" style="zoom:80%;" /></p><p>如上图，先找到位于线段 <span class="math inline">\(b_0b_1\)</span> 的<span class="math inline">\(1/t\)</span> 处的点 <spanclass="math inline">\(b_0^1\)</span> ，与位于线段 <spanclass="math inline">\(b_1b_2\)</span> 的 <spanclass="math inline">\(1/t\)</span> 处的点 <spanclass="math inline">\(b_1^1\)</span>，然后根据这两个点的连线得到一条新的线段 <spanclass="math inline">\(b_0^1b_1^1\)</span> 。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126165832698.png" style="zoom:80%;" /></p><p>在新的线段 <span class="math inline">\(b_0^1b_1^1\)</span>上，再次找到位于其 <span class="math inline">\(1/t\)</span> 处的点 <spanclass="math inline">\(b_0^2\)</span>，此时发现已经没有剩下的线段了，找不到第二个点进行连线。那么，最后的这一个点就是t 时刻的位置。</p><p>感觉挺简单，是个一看就挺递归的算法。</p><p>对于更多控制点的贝塞尔曲线也是一样道理：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126171028709.png" style="zoom:80%;" /></p><p>先在 <span class="math inline">\(b_0b_1,b_1b_2,b_2b_3\)</span>上分别找到 <span class="math inline">\(b_0^1,b_1^1,b_2^1\)</span>，将找到的点相邻之间两两连线，得到两条新的线段 <spanclass="math inline">\(b_0^1b_1^1,b_1^1b_2^1\)</span>，继续在新的线段之间找点、连线，直到再无法得到新的连线时，最后剩下的点就是t 时刻的位置。</p><figure><img src="https://hczhcz.github.io/images/2014-07-16-bezier-curve.gif"alt="wikipedia：Bézier curve" /><figcaption aria-hidden="true">wikipedia：Bézier curve</figcaption></figure><h3 id="de-casteljau-算法的代数表示">2.3 de Casteljau算法的代数表示</h3><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126174803652.png" /></p><p>de Casteljau 算法是一个对相邻点间不断做位置上的线性插值的过程。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240126165832698.png" style="zoom:80%;" /></p><p>上面这个过程，我们可以用代数将其显示地表示出来。首先先找到点 <spanclass="math inline">\(b_0^1\)</span> 和 <spanclass="math inline">\(b_1^1\)</span> 的位置:</p><p><span class="math display">\[\begin{gather*}    b_0^1(t) = (1-t)b_0 + tb_1 \\    b_1^1(t) = (1-t)b_1 + tb_2 \\\end{gather*}\]</span> 再找到点 <span class="math inline">\(b_0^2\)</span> 的位置：<span class="math display">\[b_0^2(t) = (1-t)b_0^1 + tb_1^1\]</span> 将过程展开，可以发现 <spanclass="math inline">\(b_0^2\)</span> 就是 <spanclass="math inline">\(b_0,b_1,b_2\)</span> 三个控制点的组合: <spanclass="math display">\[b_0^2(t) = (1-t)^2b_0 + 2t(1-t)b_1 + t^2b_2\]</span> 将贝塞尔曲线扩展到 n 阶，也就是 n+1 个控制点时，可以把 <spanclass="math inline">\(b^n(t)\)</span> 表示为伯恩斯坦多项式的线性组合：<span class="math display">\[b^n(t)=b_0^n(t)=\sum_{j=0}^{n}b_jB_j^n(t)\]</span> 其中伯恩斯坦多项式为: <span class="math display">\[B_i^n=\begin{pmatrix}n \\i\end{pmatrix}t^i(1-t)^{n-i}\]</span></p><h3 id="贝塞尔曲线的性质">2.4 贝塞尔曲线的性质</h3><ul><li><p>n 阶贝塞尔曲线：<span class="math inline">\(b(0)=b_0\)</span> ;<span class="math inline">\(b(1)=b(n)\)</span> ；</p></li><li><p>3 阶贝塞尔曲线：<spanclass="math inline">\(b&#39;(0)=3(b_1-b_0)\)</span> ; <spanclass="math inline">\(b&#39;(1)=3(b_3-b_2)\)</span>；</p></li><li><p>贝塞尔曲线的控制点经过<strong>仿射变换</strong>后表示的曲线，与原控制点表示的曲线经过仿射变换后相同；</p></li><li><p>贝塞尔曲线上任意一个点一定会在控制点所形成的凸包内；</p></li></ul><h3 id="分段贝塞尔曲线">2.5 分段贝塞尔曲线</h3><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127163736620.png"alt="10阶贝塞尔曲线" /><figcaption aria-hidden="true">10阶贝塞尔曲线</figcaption></figure><p>当贝塞尔曲线阶数太高，控制点太多时，会使得曲线不直观，难以控制。</p><p>那干脆就不要用太多控制点，改用较少的控制点表示其中一段贝塞尔曲线，最后将这些贝塞尔曲线连起来。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127163642256.png" style="zoom:67%;" /></p><p>通常，人们习惯把每四个控制点定义成一段贝塞尔曲线，也就是三次贝塞尔曲线（<ahref="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">BezierCurve Demos</a>）。</p><p>为了保证分段贝塞尔曲线的连续性，有以下关于连续性的规定：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127165903461.png" style="zoom:80%;" /></p><ul><li><span class="math inline">\(C^0\)</span> 连续：<spanclass="math inline">\(a_n=b_0\)</span>，前一段的终止点等于后一段的起点；</li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127170247915.png" alt="image-20240127170247915" style="zoom:80%;" /></p><ul><li><span class="math inline">\(C^1\)</span> 连续：<spanclass="math inline">\(a_n=b_0=\frac{1}{2}(a_{n-1}+b_1)\)</span>，在满足<span class="math inline">\(C^0\)</span>连续的基础上，后一段的起始方向与长度应该与前一段的终止方向与长度相同；</li></ul><p>当然还有更加高阶的连续性，称为曲率连续，在此不讨论。</p><h2 id="spline">3. Spline</h2><h3 id="什么是样条">3.1 什么是样条？</h3><p>构造为穿过给定点集并具有一定数量的连续导数的连续曲线，简而言之，一条受控的曲线。</p><h3 id="b-spline">3.2 B-Spline</h3><p>B样条是 basissplines，基函数样条的缩写，它是贝塞尔曲线的扩展，需要比贝塞尔曲线更多的信息，满足贝塞尔曲线具有的所有重要属性（即超集），有比贝塞尔曲线更好的能力（体现在局部性等等）。</p><p>B样条极其复杂，不在此入门课深入讲。</p><h2 id="bezier-surfaces">4. Bezier Surfaces</h2><p>我们可以将贝塞尔曲线延伸到曲面。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127173803614.png"alt="由4x4个点控制的贝塞尔曲面" /><figcaption aria-hidden="true">由4x4个点控制的贝塞尔曲面</figcaption></figure><p>只要在两个方向上应用贝塞尔曲线，就可以绘制一个贝塞尔曲面。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/demo.gif"alt="Steven Wittens, https://acko.net/blog/making-mathbox/" /><figcaption aria-hidden="true">Steven Wittens,https://acko.net/blog/making-mathbox/</figcaption></figure><p>首先，在平面上定义 4x4 的控制点，将其中的每一行的 4个控制点表示一条贝塞尔曲线，在不同的时间 t时，每条贝塞尔曲线所在的点会在不同的位置上：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127180824129.png" style="zoom:80%;" /></p><p>如果我们将这 4个不同的点认为是新的贝塞尔曲线的控制点，我们可以画出一条新的贝塞尔曲线：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127180956117.png" style="zoom:80%;" /></p><p>那么，这条线在另一个时间维度中扫过的空间会形成一个贝塞尔曲面：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127181236844.png" style="zoom:80%;" /></p><p>很显然，形成一个贝塞尔曲面需要两个不同的时间，常用 uv 表示。遍历uv，就可以找到曲面上所有的点。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240127181641023.png" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>几何</tag>
      
      <tag>Bézier曲线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture10 Geometry 1</title>
    <link href="/2024/01/24/Games101-Lecture-10-Geometry-1/"/>
    <url>/2024/01/24/Games101-Lecture-10-Geometry-1/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/神戸小鳥01-small.png" /></p><h1 id="geometry-1-introduction">Geometry 1 (Introduction)</h1><p>计算机图形中用隐式与显示两种不同的方式来描述几何，根据需要选择不同的表示方法。</p><h3 id="implicit-representations-of-geometry">1. ImplicitRepresentations of Geometry</h3><h4 id="什么是隐式表示">1.1 什么是隐式表示？</h4><p>通俗的讲，隐式表示不记录几何在空间中有哪些点，而是描述几何上的点在空间中都满足一个什么样的关系，只要满足这个关系的点都在几何的表面上。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124163409280.png"alt="隐式表示" /><figcaption aria-hidden="true">隐式表示</figcaption></figure><p><strong>定义一个函数 <span class="math inline">\(f(x,y,z)=0\)</span>，只要能找到任意一个点满足该函数，就认为该点在该函数表示的几何面上。</strong></p><h4 id="隐式表示的优缺点">1.2 隐式表示的优缺点</h4><ul><li><p>优点：给定一个点 <span class="math inline">\(P(x,y,z)\)</span>，很容易就能判断该点是不是在某个隐式表示的几何内，只要带入三个维度的坐标看函数值是不是等于零就可以。</p></li><li><p>缺点：<strong>不直观</strong>，给定一个隐式表示的几何，我们很难找到所有满足该隐式表示的点。也就是说，对于一个隐式表示的几何，我们很难判断它究竟是一个什么样的形状。</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124165136754.png"alt="看到表达式就头晕" /><figcaption aria-hidden="true">看到表达式就头晕</figcaption></figure><h3 id="explicit-representations-of-geometry">2. ExplicitRepresentations of Geometry</h3><p>相对的，显示表示会给出几何在空间中有哪些点，要么直接给出，要么通过<strong>参数映射</strong>的方式给出。</p><h4 id="什么是参数映射">2.1 什么是参数映射？</h4><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124164800393.png"alt="通过参数映射显示表示的马鞍面" /><figcaption aria-hidden="true">通过参数映射显示表示的马鞍面</figcaption></figure><p>定义一个函数 <span class="math inline">\(f(u,v)\)</span>，该函数将二维空间上的坐标 <span class="math inline">\((u,v)\)</span>映射到三维空间中几何的坐标上。</p><h4 id="参数映射的优缺点">2.2 参数映射的优缺点</h4><p>使用参数映射，前面那个看了头晕的甜甜圈表达式可以写成： <spanclass="math display">\[f(u,v)=((2+\cos{u})\cos{v},(2+\cos{u})\sin{v},\sin{u})\]</span> 还是看不出这个几何是个什么形状？现在只要把二维空间中的坐标<span class="math inline">\((u,v)\)</span> 全部遍历一遍。</p><p>有了以上优点，那么代价是什么？假设有一个参数映射表示的几何和一个三维空间中的点，如何才能知道这个点在不在几何里面呢？除非把这个几何画出来知道它是一个什么形状，不然不好判断。显示表示的优缺点和隐式表示恰恰相反。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124171353907.png"alt="显示表示的缺点示例" /><figcaption aria-hidden="true">显示表示的缺点示例</figcaption></figure><h3 id="more-implicit-representations-of-geometry">3. More ImplicitRepresentations of Geometry</h3><h4 id="constructive-solid-geometrycsg-implicit">3.1 Constructive SolidGeometry，CSG (Implicit)</h4><p>普通的隐式表示方法很直接，但也很复杂、不直观。只是表示一些比较规则的几何的话还能接受，但如果要它来表示复杂物体，那表达式得很有多夸张。但是我们还有另外的隐式表示方式，叫做<strong>构造实体几何（CSG）</strong>。</p><h5 id="什么是csg">什么是CSG ？</h5><p>简单的说，通过一系列基本几何的基本运算来定义新的几何的方法，叫做CSG，这种方法得到了很广泛的应用。</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124172803752.png"alt="CSG的简单示例" /><figcaption aria-hidden="true">CSG的简单示例</figcaption></figure><h4 id="distance-functions-implicit">3.2 Distance Functions(Implicit)</h4><p>距离函数也是一种隐式表示的方式，它可以简单地计算出几何的两个状态之间的中间量。</p><h5 id="什么是距离函数">什么是距离函数？</h5><p>对于任何一个几何，距离函数不直接去描述它的表面，而是去描述空间中任何一个点到这个几何的表面的最小距离。这个距离可以是正值，也可以是负值，即可以描述该点相对于几何的内外关系。例如，距离函数可以做到以下效果：</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124221305599.png" /></p><p>可以看到在上图两个小球互相融合的过程中，小球的几何形态、拓扑结构发生了改变。</p><h5id="示例使用距离函数对移动边界作-blend">示例：使用距离函数对移动边界作blend</h5><p>​ <imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124222213361.png" /></p><p>假设有如上图所示一前一后两个几何，斜线表示黑色的几何表面。A状态时，前面的几何挡住了后面的几何1/3的表面，A状态经过移动前面的几何后到达B状态，B状态时，前面的几何挡住了后面的几何2/3 的表面。我如何知道 A 与 B 之间任意一个时刻两个几何的状态？</p><p>如果我们简单地对 A 与 B 状态做一个线性的blend，我们的中间区域将会得到一个介于黑色与白色之间的结果，这显然是不对的。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124223330365.png" /></p><p>SDF 是符号距离函数，也就是 Sign Distance Function，如果使用 SDF表示这两个几何，中间的黑线（0所在的位置）表示几何的边界，红线的密集程度越大，表示该处距离边界的距离越小。将这两个SDF 进行 blend，显然我们可以在中间的某处得到一条新的值为 0的线，也就是新的边界。</p><p>简单的说，对两个对应的 SDF 进行 blend，就是在对它们的边界进行blend.</p><h4 id="level-set-methods-implicit">3.3 Level Set Methods(Implicit)</h4><p>但一个几何的形态过于复杂，以至于不好用函数的方式对它进行表示的时候，我们可以采用另一种表示的方法——水平集。</p><h5 id="什么是水平集">什么是水平集？</h5><p>水平集的想法与距离函数基本相同，但表示方式不同。水平集用一张图来描述几何，如：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240124225357715.png"alt="image-20240124225357715" /><figcaption aria-hidden="true">image-20240124225357715</figcaption></figure><p>我只需要找到图上等于零的位置的集合，我就可以找到该水平集所表示的几何的边界，就像地理上的等高线。如果我们把这个图扩展到三维，同样可以表示三维空间中的几何的边界。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - 作业3</title>
    <link href="/2024/01/22/Games101-%E4%BD%9C%E4%B8%9A3/"/>
    <url>/2024/01/22/Games101-%E4%BD%9C%E4%B8%9A3/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/hinami.png"alt="?" /><figcaption aria-hidden="true">?</figcaption></figure><p>终于把期末的麻烦事都做完了QAQ，微机原理真不是人学的（</p><p>本次作业3的框架有了很大变化，新增了 OBJ加载器，纹理加载器以及着色器结构体，程序流程也从原本的硬解码三角形变为流水线运行，具体流程为：从模型中读取并保存为Triangle 类型，再加入 TriangleList 容器队列 -&gt; 设置渲染器类型 -&gt;渲染。</p><ol type="1"><li>修改函数 rasterize_triangle(const Triangle&amp; t) inrasterizer.cpp: 在此 处实现与作业 2类似的插值算法，实现法向量、颜色、纹理颜色的插值。<ul><li>根据提示写，计算三角形内pixel的重心坐标，使用重心坐标完成要求的各种属性插值并传递给着色器。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">rasterize_triangle</span>(<span class="hljs-type">const</span> Triangle&amp; t, <span class="hljs-type">const</span> std::array&lt;Eigen::Vector3f, <span class="hljs-number">3</span>&gt;&amp; view_pos) <br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> From your HW3, get the triangle rasterization code.</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Inside your rasterization loop:</span><br>    <span class="hljs-comment">//    * v[i].w() is the vertex view space depth value z.</span><br>    <span class="hljs-comment">//    * Z is interpolated view space depth for the current pixel</span><br>    <span class="hljs-comment">//    * zp is depth between zNear and zFar, used for z-buffer</span><br><br>    <span class="hljs-comment">// float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br>    <span class="hljs-comment">// float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br>    <span class="hljs-comment">// zp *= Z;</span><br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Interpolate the attributes:</span><br>    <span class="hljs-comment">// auto interpolated_color</span><br>    <span class="hljs-comment">// auto interpolated_normal</span><br>    <span class="hljs-comment">// auto interpolated_texcoords</span><br>    <span class="hljs-comment">// auto interpolated_shadingcoords</span><br><br>    <span class="hljs-comment">// Use: fragment_shader_payload payload( interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);</span><br>    <span class="hljs-comment">// Use: payload.view_pos = interpolated_shadingcoords;</span><br>    <span class="hljs-comment">// Use: Instead of passing the triangle&#x27;s color directly to the frame buffer, pass the color to the shaders first to get the final color;</span><br>    <span class="hljs-comment">// Use: auto pixel_color = fragment_shader(payload);</span><br><br>    <span class="hljs-keyword">auto</span> v = t.<span class="hljs-built_in">toVector4</span>();<br><br>    <span class="hljs-comment">// Bounding Box</span><br>    <span class="hljs-type">int</span> min_x = INT32_MAX, min_y = INT32_MAX, max_x = INT32_MIN, max_y = INT32_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : v)&#123;<br>        min_x = min_x &gt; p[<span class="hljs-number">0</span>] ? p[<span class="hljs-number">0</span>] : min_x;<br>        min_y = min_y &gt; p[<span class="hljs-number">1</span>] ? p[<span class="hljs-number">1</span>] : min_y;<br>        max_x = max_x &lt; p[<span class="hljs-number">0</span>] ? p[<span class="hljs-number">0</span>] : max_x;<br>        max_y = max_y &lt; p[<span class="hljs-number">1</span>] ? p[<span class="hljs-number">1</span>] : max_y;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = min_y; y &lt;= max_y; y++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = min_x; x &lt;= max_x; x++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">insideTriangle</span>((<span class="hljs-type">float</span>)x + <span class="hljs-number">0.5</span>, (<span class="hljs-type">float</span>)y + <span class="hljs-number">0.5</span>, t.v))&#123;<br>                <span class="hljs-comment">// 在三角形内</span><br>                <span class="hljs-comment">// 计算重心坐标</span><br>                <span class="hljs-keyword">auto</span> cb2 = <span class="hljs-built_in">computeBarycentric2D</span>((<span class="hljs-type">float</span>)x + <span class="hljs-number">0.5</span>, (<span class="hljs-type">float</span>)y + <span class="hljs-number">0.5</span>, t.v);<br>                <span class="hljs-type">float</span> alpha = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(cb2), beta = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(cb2), gamma = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(cb2);<br>                <span class="hljs-comment">// z-buffer 插值</span><br>                <span class="hljs-type">float</span> Z = <span class="hljs-number">1.0</span> / (alpha / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>());<br>                <span class="hljs-type">float</span> zp = alpha * v[<span class="hljs-number">0</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta * v[<span class="hljs-number">1</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma * v[<span class="hljs-number">2</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>();<br>                zp *= Z;<br><br>                <span class="hljs-keyword">if</span>(zp &lt; depth_buf[<span class="hljs-built_in">get_index</span>(x, y)])&#123;<br>                    depth_buf[<span class="hljs-built_in">get_index</span>(x, y)] = zp;<br><br>                    <span class="hljs-comment">// 颜色插值</span><br>                    <span class="hljs-keyword">auto</span> interpolated_color = <span class="hljs-built_in">interpolate</span>(alpha, beta, gamma, t.color[<span class="hljs-number">0</span>], t.color[<span class="hljs-number">1</span>], t.color[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// 法向量插值</span><br>                    <span class="hljs-keyword">auto</span> interpolated_normal = <span class="hljs-built_in">interpolate</span>(alpha, beta, gamma, t.normal[<span class="hljs-number">0</span>], t.normal[<span class="hljs-number">1</span>], t.normal[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// 纹理颜色插值</span><br>                    <span class="hljs-keyword">auto</span> interpolated_texcoords = <span class="hljs-built_in">interpolate</span>(alpha, beta, gamma, t.tex_coords[<span class="hljs-number">0</span>], t.tex_coords[<span class="hljs-number">1</span>], t.tex_coords[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// 纹理坐标插值</span><br>                    <span class="hljs-keyword">auto</span> interpolated_shadingcoords = <span class="hljs-built_in">interpolate</span>(alpha, beta, gamma, view_pos[<span class="hljs-number">0</span>], view_pos[<span class="hljs-number">1</span>], view_pos[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br><br>                    <span class="hljs-function">fragment_shader_payload <span class="hljs-title">payload</span><span class="hljs-params">( interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : <span class="hljs-literal">nullptr</span>)</span></span>;<br>                    payload.view_pos = interpolated_shadingcoords;<br>                    <span class="hljs-keyword">auto</span> pixel_color = <span class="hljs-built_in">fragment_shader</span>(payload);<br>                    <span class="hljs-built_in">set_pixel</span>(<span class="hljs-built_in">Vector2i</span>(x, (<span class="hljs-type">float</span>)y), pixel_color);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>修改函数 get_projection_matrix() in main.cpp:将你自己在之前的实验中实现的投影矩阵填到此处，此时你可以运行./Rasterizer output.png normal来观察法向量实现结果。<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/normal.png" alt="normal牛牛" style="zoom:80%;" /></p></li><li><p>修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong模型计算 Fragment Color.</p><ul><li><p>阅读提供的代码，了解下给的变量是什么，根据课程的内容计算环境光、漫反射和高光，注意下使用方向向量。</p></li><li><p><span class="math display">\[\begin{gather*}L=L_a+L_d+L_s\\=k_aI_a+k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})+max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p\end{gather*}\]</span></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/phong.png" alt="phong牛牛" style="zoom:80%;" /></p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">phong_fragment_shader</span><span class="hljs-params">(<span class="hljs-type">const</span> fragment_shader_payload&amp; payload)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 漫反射系数</span><br>    Eigen::Vector3f ka = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>);<br>    Eigen::Vector3f kd = payload.color;<br>    <span class="hljs-comment">// 高光系数</span><br>    Eigen::Vector3f ks = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>);<br><br>    <span class="hljs-comment">// &#123;坐标， 强度&#125;</span><br>    <span class="hljs-keyword">auto</span> l1 = light&#123;&#123;<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> l2 = light&#123;&#123;<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br><br>    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;<br>    <span class="hljs-comment">// 环境光强度</span><br>    Eigen::Vector3f amb_light_intensity&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>&#125;;<br>    Eigen::Vector3f eye_pos&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>&#125;;<br><br>    <span class="hljs-type">float</span> p = <span class="hljs-number">150</span>;<br><br>    Eigen::Vector3f color = payload.color;<br>    Eigen::Vector3f point = payload.view_pos;<br>    Eigen::Vector3f normal = payload.normal;<br><br>    Eigen::Vector3f result_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; light : lights)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span><br>        <span class="hljs-keyword">auto</span> v = eye_pos - point;  <span class="hljs-comment">// 观察方向 v</span><br>        <span class="hljs-keyword">auto</span> l = light.position - point;    <span class="hljs-comment">// 光照方向 l</span><br>        <span class="hljs-keyword">auto</span> h = (l.<span class="hljs-built_in">normalized</span>() + v.<span class="hljs-built_in">normalized</span>()).<span class="hljs-built_in">normalized</span>();     <span class="hljs-comment">// 半程向量 h</span><br>        <span class="hljs-keyword">auto</span> r = l.<span class="hljs-built_in">dot</span>(l);                  <span class="hljs-comment">// 光照强度的衰减距离 r^2</span><br>        <span class="hljs-comment">// 环境光</span><br>        <span class="hljs-keyword">auto</span> ambient = ka.<span class="hljs-built_in">cwiseProduct</span>(amb_light_intensity);<br>        <span class="hljs-comment">// 漫反射</span><br>        <span class="hljs-keyword">auto</span> diffuse = kd.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(l.<span class="hljs-built_in">normalized</span>()));<br>        <span class="hljs-comment">// 高光</span><br>        <span class="hljs-keyword">auto</span> specular = ks.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(h.<span class="hljs-built_in">normalized</span>())), p);<br><br>        <span class="hljs-comment">// components are. Then, accumulate that result on the *result_color* object.</span><br>        result_color = result_color + ambient + diffuse + specular;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong的基础上，将纹理颜色视为公式中的 kd，实现 Texture Shading FragmentShader.<ul><li>在 phong shader 的基础上，将 kd 替换为使用 getColor方法查找纹理图得到的颜色值</li><li>这里有个坑，作业框架提供的getColcor方法没有做越界检查，可能出现负值的坐标导致越界错误<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/texture.png" alt="texture牛牛" style="zoom:80%;" /></li></ul></li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 添加越界的检查和处理</span><br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">getColor</span><span class="hljs-params">(<span class="hljs-type">float</span> u, <span class="hljs-type">float</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    u = u &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : u &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : u;<br>    v = v &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : v &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : v;<br>    <span class="hljs-keyword">auto</span> u_img = u * width;<br>    <span class="hljs-keyword">auto</span> v_img = (<span class="hljs-number">1</span> - v) * height;<br>    <span class="hljs-keyword">auto</span> color = image_data.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(v_img, u_img);<br>    <span class="hljs-keyword">return</span> Eigen::<span class="hljs-built_in">Vector3f</span>(color[<span class="hljs-number">0</span>], color[<span class="hljs-number">1</span>], color[<span class="hljs-number">2</span>]);<br>&#125;<br><br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">texture_fragment_shader</span><span class="hljs-params">(<span class="hljs-type">const</span> fragment_shader_payload&amp; payload)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 在 phong shader 的基础上，将 kd 替换为使用 getColor 方法查找纹理图得到的颜色值</span><br>    Eigen::Vector3f return_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span> (payload.texture)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Get the texture value at the texture coordinates of the current fragment</span><br>        <span class="hljs-comment">// 这里有个坑，作业框架提供的getColcor方法没有做越界检查，可能出现负值的坐标导致越界错误</span><br>        return_color = payload.texture-&gt;<span class="hljs-built_in">getColor</span>(payload.tex_coords.<span class="hljs-built_in">x</span>(), payload.tex_coords.<span class="hljs-built_in">y</span>());<br>    &#125;<br>    Eigen::Vector3f texture_color;<br>    texture_color &lt;&lt; return_color.<span class="hljs-built_in">x</span>(), return_color.<span class="hljs-built_in">y</span>(), return_color.<span class="hljs-built_in">z</span>();<br><br>    Eigen::Vector3f ka = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>);<br>    Eigen::Vector3f kd = texture_color / <span class="hljs-number">255.f</span>;<br>    Eigen::Vector3f ks = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>);<br><br>    <span class="hljs-keyword">auto</span> l1 = light&#123;&#123;<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> l2 = light&#123;&#123;<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br><br>    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;<br>    Eigen::Vector3f amb_light_intensity&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>&#125;;<br>    Eigen::Vector3f eye_pos&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-type">float</span> p = <span class="hljs-number">150</span>;<br><br>    Eigen::Vector3f color = texture_color;<br>    Eigen::Vector3f point = payload.view_pos;<br>    Eigen::Vector3f normal = payload.normal;<br><br>    Eigen::Vector3f result_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; light : lights)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span><br>        <span class="hljs-keyword">auto</span> v = eye_pos - point;  <span class="hljs-comment">// 观察方向 v</span><br>        <span class="hljs-keyword">auto</span> l = light.position - point;    <span class="hljs-comment">// 光照方向 l</span><br>        <span class="hljs-keyword">auto</span> h = (l.<span class="hljs-built_in">normalized</span>() + v.<span class="hljs-built_in">normalized</span>()).<span class="hljs-built_in">normalized</span>();     <span class="hljs-comment">// 半程向量 h</span><br>        <span class="hljs-keyword">auto</span> r = l.<span class="hljs-built_in">dot</span>(l);                  <span class="hljs-comment">// 光照强度的衰减距离 r^2</span><br>        <span class="hljs-comment">// 环境光</span><br>        <span class="hljs-keyword">auto</span> ambient = ka.<span class="hljs-built_in">cwiseProduct</span>(amb_light_intensity);<br>        <span class="hljs-comment">// 漫反射</span><br>        <span class="hljs-keyword">auto</span> diffuse = kd.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(l.<span class="hljs-built_in">normalized</span>()));<br>        <span class="hljs-comment">// 高光</span><br>        <span class="hljs-keyword">auto</span> specular = ks.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(h.<span class="hljs-built_in">normalized</span>())), p);<br><br>        <span class="hljs-comment">// components are. Then, accumulate that result on the *result_color* object.</span><br>        result_color = result_color + ambient + diffuse + specular;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol start="5" type="1"><li><p>修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong的基础上，仔细阅读该函数中的注释，实现 Bump mapping.</p><ul><li><p>计算新的法线，<ahref="https://memo2586.github.io/2023/12/08/Games101-Lecture-09-Shading-3/#applications-of-textures">简单推导</a>：<span class="math display">\[\begin{gather*}dp/du=c1*[h[u+1]-h[u]]\\dp/dv=c2*[h[v+1]-h[v]]\\n=(-dp/du,-dp/dv,1).normalized()\end{gather*}\]</span></p></li><li><p>使用 btn 矩阵将法线从切线空间转换到世界空间，推导过程见<ahref="https://zhuanlan.zhihu.com/p/517241213">Keanu -（超详细！）计算机图形学 补充篇 2.关于阴影与法线贴图</a>.<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/bump.png" alt="bump牛牛" style="zoom:80%;" /></p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">bump_fragment_shader</span><span class="hljs-params">(<span class="hljs-type">const</span> fragment_shader_payload &amp;payload)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Eigen::Vector3f ka = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>);<br>    Eigen::Vector3f kd = payload.color;<br>    Eigen::Vector3f ks = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>);<br><br>    <span class="hljs-keyword">auto</span> l1 = light&#123;&#123;<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> l2 = light&#123;&#123;<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br><br>    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;<br>    Eigen::Vector3f amb_light_intensity&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>&#125;;<br>    Eigen::Vector3f eye_pos&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>&#125;;<br><br>    <span class="hljs-type">float</span> p = <span class="hljs-number">150</span>;<br><br>    Eigen::Vector3f color = payload.color;<br>    Eigen::Vector3f point = payload.view_pos;<br>    Eigen::Vector3f normal = payload.normal;<br><br>    <span class="hljs-type">float</span> kh = <span class="hljs-number">0.2</span>, kn = <span class="hljs-number">0.1</span>;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement bump mapping here</span><br>    <span class="hljs-comment">// Let n = normal = (x, y, z)</span><br>    <span class="hljs-comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span><br>    <span class="hljs-comment">// Vector b = n cross product t</span><br>    <span class="hljs-comment">// Matrix TBN = [t b n]</span><br>    <span class="hljs-comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span><br>    <span class="hljs-comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span><br>    <span class="hljs-comment">// Vector ln = (-dU, -dV, 1)</span><br>    <span class="hljs-comment">// Normal n = normalize(TBN * ln)</span><br><br>    <span class="hljs-type">float</span> x = normal.<span class="hljs-built_in">x</span>(), y = normal.<span class="hljs-built_in">y</span>(), z = normal.<span class="hljs-built_in">z</span>();<br><br>    Eigen::Vector3f t = Eigen::<span class="hljs-built_in">Vector3f</span>(x * y / std::<span class="hljs-built_in">sqrt</span>(x * x + z * z), std::<span class="hljs-built_in">sqrt</span>(x * x + z * z), z * y / std::<span class="hljs-built_in">sqrt</span>(x * x + z * z));<br>    Eigen::Vector3f b = normal.<span class="hljs-built_in">cross</span>(t);<br><br>    <span class="hljs-comment">// TBN 矩阵，用于计算法线从切线空间到世界空间的转换，推导过程https://zhuanlan.zhihu.com/p/517241213</span><br>    Eigen::Matrix3f TBN;<br>    TBN &lt;&lt; t.<span class="hljs-built_in">x</span>(), b.<span class="hljs-built_in">x</span>(), normal.<span class="hljs-built_in">x</span>(),<br>        t.<span class="hljs-built_in">y</span>(), b.<span class="hljs-built_in">y</span>(), normal.<span class="hljs-built_in">y</span>(),<br>        t.<span class="hljs-built_in">z</span>(), b.<span class="hljs-built_in">z</span>(), normal.<span class="hljs-built_in">z</span>();<br><br>    <span class="hljs-type">float</span> u = payload.tex_coords.<span class="hljs-built_in">x</span>(), v = payload.tex_coords.<span class="hljs-built_in">y</span>();<br>    <span class="hljs-type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;<br><br>    <span class="hljs-type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u + <span class="hljs-number">1.0f</span> / w, v).<span class="hljs-built_in">norm</span>() - payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v).<span class="hljs-built_in">norm</span>());<br>    <span class="hljs-type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v + <span class="hljs-number">1.0f</span> / h).<span class="hljs-built_in">norm</span>() - payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v).<span class="hljs-built_in">norm</span>());<br>    Eigen::Vector3f ln = Eigen::<span class="hljs-built_in">Vector3f</span>(-dU, -dV, <span class="hljs-number">1.0f</span>);<br>    normal = TBN * ln;<br><br>    Eigen::Vector3f result_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    result_color = normal.<span class="hljs-built_in">normalized</span>();<br><br>    <span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bumpmapping 的基础上，实现 displacement mapping.</li></ol><ul><li>和 Bump mapping 不同的是使用改变后的点的世界坐标进行了phongshading，在将切线空间的法向量向世界空间变换前，应该先计算该点的新坐标。<img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/1%20(2).png" alt="displacement牛牛" style="zoom:80%;" /></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">displacement_fragment_shader</span><span class="hljs-params">(<span class="hljs-type">const</span> fragment_shader_payload &amp;payload)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Eigen::Vector3f ka = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>, <span class="hljs-number">0.005</span>);<br>    Eigen::Vector3f kd = payload.color;<br>    Eigen::Vector3f ks = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>, <span class="hljs-number">0.7937</span>);<br><br>    <span class="hljs-keyword">auto</span> l1 = light&#123;&#123;<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> l2 = light&#123;&#123;<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125;&#125;;<br><br>    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;<br>    Eigen::Vector3f amb_light_intensity&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>&#125;;<br>    Eigen::Vector3f eye_pos&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>&#125;;<br><br>    <span class="hljs-type">float</span> p = <span class="hljs-number">150</span>;<br><br>    Eigen::Vector3f color = payload.color;<br>    Eigen::Vector3f point = payload.view_pos;<br>    Eigen::Vector3f normal = payload.normal;<br><br>    <span class="hljs-type">float</span> kh = <span class="hljs-number">0.2</span>, kn = <span class="hljs-number">0.1</span>;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement displacement mapping here</span><br>    <span class="hljs-comment">// Let n = normal = (x, y, z)</span><br>    <span class="hljs-comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span><br>    <span class="hljs-comment">// Vector b = n cross product t</span><br>    <span class="hljs-comment">// Matrix TBN = [t b n]</span><br>    <span class="hljs-comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span><br>    <span class="hljs-comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span><br>    <span class="hljs-comment">// Vector ln = (-dU, -dV, 1)</span><br>    <span class="hljs-comment">// Position p = p + kn * n * h(u,v)</span><br>    <span class="hljs-comment">// Normal n = normalize(TBN * ln)</span><br><br>    <span class="hljs-type">float</span> x = normal.<span class="hljs-built_in">x</span>(), y = normal.<span class="hljs-built_in">y</span>(), z = normal.<span class="hljs-built_in">z</span>();<br><br>    Eigen::Vector3f t = Eigen::<span class="hljs-built_in">Vector3f</span>(x * y / std::<span class="hljs-built_in">sqrt</span>(x * x + z * z), std::<span class="hljs-built_in">sqrt</span>(x * x + z * z), z * y / std::<span class="hljs-built_in">sqrt</span>(x * x + z * z));<br>    Eigen::Vector3f b = normal.<span class="hljs-built_in">cross</span>(t);<br><br>    Eigen::Matrix3f TBN;<br>    TBN &lt;&lt; t.<span class="hljs-built_in">x</span>(), b.<span class="hljs-built_in">x</span>(), normal.<span class="hljs-built_in">x</span>(),<br>        t.<span class="hljs-built_in">y</span>(), b.<span class="hljs-built_in">y</span>(), normal.<span class="hljs-built_in">y</span>(),<br>        t.<span class="hljs-built_in">z</span>(), b.<span class="hljs-built_in">z</span>(), normal.<span class="hljs-built_in">z</span>();<br><br>    <span class="hljs-type">float</span> u = payload.tex_coords.<span class="hljs-built_in">x</span>(), v = payload.tex_coords.<span class="hljs-built_in">y</span>();<br>    <span class="hljs-type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;<br><br>    <span class="hljs-type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u + <span class="hljs-number">1.0f</span> / w, v).<span class="hljs-built_in">norm</span>() - payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v).<span class="hljs-built_in">norm</span>());<br>    <span class="hljs-type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v + <span class="hljs-number">1.0f</span> / h).<span class="hljs-built_in">norm</span>() - payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v).<span class="hljs-built_in">norm</span>());<br><br>    Eigen::Vector3f ln = Eigen::<span class="hljs-built_in">Vector3f</span>(-dU, -dV, <span class="hljs-number">1.0f</span>);<br><br>    <span class="hljs-comment">// 改变目标点高度</span><br>    point += (kn * normal * payload.texture-&gt;<span class="hljs-built_in">getColor</span>(u, v).<span class="hljs-built_in">norm</span>());<br>    <span class="hljs-comment">// 改变后的世界坐标法线</span><br>    normal = (TBN * ln).<span class="hljs-built_in">normalized</span>();<br><br>    Eigen::Vector3f result_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;light : lights)<br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*</span><br>        <span class="hljs-comment">// components are. Then, accumulate that result on the *result_color* object.</span><br>        <br>        <span class="hljs-comment">// 光照方向、观察方向、半程向量</span><br>        <span class="hljs-keyword">auto</span> v = eye_pos - point;  <span class="hljs-comment">// 观察方向 v</span><br>        <span class="hljs-keyword">auto</span> l = light.position - point;    <span class="hljs-comment">// 光照方向 l</span><br>        <span class="hljs-keyword">auto</span> h = (l.<span class="hljs-built_in">normalized</span>() + v.<span class="hljs-built_in">normalized</span>()).<span class="hljs-built_in">normalized</span>();     <span class="hljs-comment">// 半程向量 h</span><br>        <span class="hljs-keyword">auto</span> r = l.<span class="hljs-built_in">dot</span>(l);                  <span class="hljs-comment">// 光照强度的衰减距离 r^2</span><br>        <span class="hljs-comment">// 环境光</span><br>        <span class="hljs-keyword">auto</span> ambient = ka.<span class="hljs-built_in">cwiseProduct</span>(amb_light_intensity);<br>        <span class="hljs-comment">// 漫反射</span><br>        <span class="hljs-keyword">auto</span> diffuse = kd.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(l.<span class="hljs-built_in">normalized</span>()));<br>        <span class="hljs-comment">// 高光</span><br>        <span class="hljs-keyword">auto</span> specular = ks.<span class="hljs-built_in">cwiseProduct</span>(light.intensity / r) * std::<span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(<span class="hljs-number">.0</span>f, normal.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(h.<span class="hljs-built_in">normalized</span>())), p);<br><br>        <span class="hljs-comment">// components are. Then, accumulate that result on the *result_color* object.</span><br>        result_color = result_color + ambient + diffuse + specular;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>光栅化</tag>
      
      <tag>纹理图</tag>
      
      <tag>代码实现</tag>
      
      <tag>渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - 作业2</title>
    <link href="/2023/12/10/Games101-%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2023/12/10/Games101-%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/kano.png" /></p><ul><li><p>在上一次作业的基础上自己编写 rasterize_wireframe(constTriangle&amp; t) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">insideTriangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Vector3f* _v)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span><br>    <span class="hljs-function">Eigen::Vector3f <span class="hljs-title">P</span><span class="hljs-params">(x, y, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>        <span class="hljs-comment">// 算出两两之间的向量</span><br>        Eigen::Vector3f u = _v[i], v = _v[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>        Eigen::Vector3f u_v = v - u, u_p = P - u;<br>        <span class="hljs-comment">// 叉积判断P点是否在三角形里</span><br>        <span class="hljs-type">float</span> k = u_v.<span class="hljs-built_in">cross</span>(u_p).<span class="hljs-built_in">z</span>();<br>        <span class="hljs-comment">// 在边缘上不管</span><br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">bool</span> st = k &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                flag = st;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 存在P点在不同方向</span><br>            <span class="hljs-keyword">if</span>(flag != st) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//Screen space rasterization</span><br><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">rasterize_triangle</span>(<span class="hljs-type">const</span> Triangle&amp; t) &#123;<br>    <span class="hljs-comment">// toVector4函数返回一个存储三角形三个顶点的齐次坐标的，长度为3的数组。</span><br>    <span class="hljs-keyword">auto</span> v = t.<span class="hljs-built_in">toVector4</span>();<br>    <br>    <span class="hljs-comment">// TODO : Find out the bounding box of current triangle.</span><br>    <span class="hljs-comment">// 算一下bonding box</span><br>    <span class="hljs-type">float</span> min_x = width, max_x = <span class="hljs-number">0</span>, min_y = height, max_y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>        min_x = std::<span class="hljs-built_in">min</span>(min_x, v[i].<span class="hljs-built_in">x</span>());<br>        min_y = std::<span class="hljs-built_in">min</span>(min_y, v[i].<span class="hljs-built_in">y</span>());<br>        max_x = std::<span class="hljs-built_in">max</span>(max_x, v[i].<span class="hljs-built_in">x</span>());<br>        max_y = std::<span class="hljs-built_in">max</span>(max_y, v[i].<span class="hljs-built_in">y</span>());<br>    &#125;<br>    <span class="hljs-comment">// iterate through the pixel and find if the current pixel is inside the triangle</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = (<span class="hljs-type">int</span>)min_y; y &lt; max_y; y++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)min_x; x &lt; max_x; x++)&#123;<br>            <span class="hljs-comment">//判断是否在三角形内</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">insideTriangle</span>(x + <span class="hljs-number">0.5</span>, y + <span class="hljs-number">0.5</span>, t.v))&#123;<br>                <span class="hljs-comment">// If so, use the following code to get the interpolated z value.</span><br>                <span class="hljs-comment">// 给的代码实在还是看不懂 orz</span><br>                <span class="hljs-keyword">auto</span>[alpha, beta, gamma] = <span class="hljs-built_in">computeBarycentric2D</span>(x, y, t.v);<br>                <span class="hljs-type">float</span> w_reciprocal = <span class="hljs-number">1.0</span>/(alpha / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>());<br>                <span class="hljs-type">float</span> z_interpolated = alpha * v[<span class="hljs-number">0</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta * v[<span class="hljs-number">1</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma * v[<span class="hljs-number">2</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>();<br>                z_interpolated *= w_reciprocal;<br><br>                <span class="hljs-comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span><br>                <span class="hljs-type">int</span> ind = <span class="hljs-built_in">get_index</span>(x, y);<br>                <span class="hljs-comment">// 检查是否为更近的点</span><br>                <span class="hljs-keyword">if</span>(z_interpolated &lt; depth_buf[ind])&#123;<br>                    <span class="hljs-comment">// 更新depth_buf</span><br>                    depth_buf[ind] = z_interpolated;<br>                    <span class="hljs-comment">// 更新frame_buf</span><br>                    Eigen::Vector3f newDepth;<br>                    <span class="hljs-comment">// 更新pixel</span><br>                    newDepth &lt;&lt; x, y, z_interpolated;<br>                    <span class="hljs-built_in">set_pixel</span>(newDepth, t.<span class="hljs-built_in">getColor</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果有明显锯齿</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/none.png"alt="none" /><figcaption aria-hidden="true">none</figcaption></figure></li><li><p>提高部分要求完成SSAA，具体思路就是使用frame_buf_ssaa和depth_buf_ssaa存储超采样的小像素的信息，然后对每个大像素里的所有小像素做朴素版本同样的操作，然后将这些小像素的frame_buf_ssaa累加后求平均就能得到大像素frame_buf的值了。在大像素内部如何完成遍历小像素只要画个图就明白了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">rasterize_triangle</span>(<span class="hljs-type">const</span> Triangle&amp; t) &#123;<br>    <br>    ......<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = (<span class="hljs-type">int</span>)min_y; y &lt; max_y; y++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)min_x; x &lt; max_x; x++)&#123;<br>        <br>            <span class="hljs-type">float</span> k = <span class="hljs-number">1.0</span> / ssaa_w * <span class="hljs-number">1.0</span>;<br>            <span class="hljs-type">float</span> sp = k / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-function">Eigen::Vector3f <span class="hljs-title">Color</span><span class="hljs-params">(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>)</span></span>;<br>            <span class="hljs-comment">// 遍历小像素</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> j = sp; j &lt; <span class="hljs-number">1.0</span>; j += k)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> i = sp; i &lt; <span class="hljs-number">1.0</span>; i += k)&#123;<br>                <span class="hljs-comment">// 这里编号的计算方式有点不同</span><br>                    <span class="hljs-type">int</span> ind = <span class="hljs-built_in">get_index_ssaa</span>(x, y, i, j);<br>                    <span class="hljs-comment">// 检查是否在三角形内</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">insideTriangle</span>(x + i, y + j, t.v))&#123;<br>                        <span class="hljs-comment">// If so, use the following code to get the interpolated z value.</span><br>                        <span class="hljs-keyword">auto</span>[alpha, beta, gamma] = <span class="hljs-built_in">computeBarycentric2D</span>(x, y, t.v);<br>                        <span class="hljs-type">float</span> w_reciprocal = <span class="hljs-number">1.0</span>/(alpha / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>());<br>                        <span class="hljs-type">float</span> z_interpolated = alpha * v[<span class="hljs-number">0</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta * v[<span class="hljs-number">1</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma * v[<span class="hljs-number">2</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>();<br>                        z_interpolated *= w_reciprocal;<br><span class="hljs-comment">// 检查是否是更近的</span><br>                        <span class="hljs-keyword">if</span>(z_interpolated &lt; depth_buf_ssaa[ind])&#123;<br>                            depth_buf_ssaa[ind] = z_interpolated;<br>                            frame_buf_ssaa[ind] = t.<span class="hljs-built_in">getColor</span>();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 累加这个小像素的frame值</span><br>                    Color += frame_buf_ssaa[ind];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//遍历完一个大像素内所有小像素，来求个平均</span><br>            Eigen::Vector3f P;<br>                P &lt;&lt; x, y, <span class="hljs-number">0.</span>;<br>                <span class="hljs-comment">// 更新pixel</span><br>                <span class="hljs-built_in">set_pixel</span>(P, Color / (ssaa_w * ssaa_h));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 需要做修改的</span><br><br><span class="hljs-comment">// ssaa构造</span><br>rst::rasterizer::<span class="hljs-built_in">rasterizer</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> sw, <span class="hljs-type">int</span> sh) : <span class="hljs-built_in">width</span>(w), <span class="hljs-built_in">height</span>(h), <span class="hljs-built_in">ssaa_w</span>(sw), <span class="hljs-built_in">ssaa_h</span>(sh)&#123;<br>    frame_buf.<span class="hljs-built_in">resize</span>(w * h);<br>    depth_buf.<span class="hljs-built_in">resize</span>(w * h);<br>    depth_buf_ssaa.<span class="hljs-built_in">resize</span>(w * sw * h * sh);<br>    frame_buf_ssaa.<span class="hljs-built_in">resize</span>(w * sw * h * sh);<br>&#125;<br><br><span class="hljs-comment">// ssaa获取id</span><br><span class="hljs-type">int</span> rst::rasterizer::<span class="hljs-built_in">get_index_ssaa</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">float</span> i, <span class="hljs-type">float</span> j)&#123;<br>    <span class="hljs-comment">// 画个图就懂了</span><br>    <span class="hljs-type">float</span> k = <span class="hljs-number">1.0</span> / ssaa_w * <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span> sp = k / <span class="hljs-number">2.0</span>;<br><br>    <span class="hljs-type">int</span> width_ssaa = ssaa_w * width, height_ssaa = ssaa_h * height;<br>    <span class="hljs-type">int</span> p_x = (i - sp) / k, p_y = (j - sp) / k;<br><br>    <span class="hljs-keyword">return</span> (height_ssaa - <span class="hljs-number">1</span> - ssaa_h * y + p_y) * width_ssaa + x * ssaa_w + p_x - height_ssaa;<br>&#125;<br><br><span class="hljs-comment">// ssaa初始化buf</span><br><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">clear_ssaa</span>(rst::Buffers buff)&#123;<br>    <span class="hljs-keyword">if</span> ((buff &amp; rst::Buffers::Color) == rst::Buffers::Color)<br>    &#123;<br>        std::<span class="hljs-built_in">fill</span>(frame_buf.<span class="hljs-built_in">begin</span>(), frame_buf.<span class="hljs-built_in">end</span>(), Eigen::Vector3f&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        std::<span class="hljs-built_in">fill</span>(frame_buf_ssaa.<span class="hljs-built_in">begin</span>(), frame_buf_ssaa.<span class="hljs-built_in">end</span>(), Eigen::Vector3f&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((buff &amp; rst::Buffers::Depth) == rst::Buffers::Depth)<br>    &#123;<br>        std::<span class="hljs-built_in">fill</span>(depth_buf.<span class="hljs-built_in">begin</span>(), depth_buf.<span class="hljs-built_in">end</span>(), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">infinity</span>());<br>        std::<span class="hljs-built_in">fill</span>(depth_buf_ssaa.<span class="hljs-built_in">begin</span>(), depth_buf_ssaa.<span class="hljs-built_in">end</span>(), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">infinity</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 记得改一下参数类型</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">insideTriangle</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">const</span> Vector3f* _v)</span></span>;<br></code></pre></td></tr></table></figure><p>最后记得改头文件，把用到的变量和函数声明加上。</p><p>贴一下效果图：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/SSAA2x2.png"alt="SSAA2x2" /><figcaption aria-hidden="true">SSAA2x2</figcaption></figure><center><p><i>SSAA2x2</i></p></center></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>光栅化</tag>
      
      <tag>反走样</tag>
      
      <tag>代码实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gmaes101 - Lecture09 Shading 3</title>
    <link href="/2023/12/08/Games101-Lecture-09-Shading-3/"/>
    <url>/2023/12/08/Games101-Lecture-09-Shading-3/</url>
    
    <content type="html"><![CDATA[<h1 id="shading-3">Shading 3</h1><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/朝日x里想奈-small.png" /></p><h3 id="barycentric-coordinates">1. Barycentric Coordinates</h3><ul><li><p><strong>为什么要使用重心坐标在三角形内部进行插值？</strong></p><p>我们在前面所学的内容中，很多操作都是在三角形的顶点上计算完成的，同时，我们又希望这些操作能在三角形内部有一个平滑的过度。为此，我们需要使用重心坐标进行插值。</p></li><li><p><strong>对什么进行重心插值？</strong></p><p>插值的内容可以有很多，例如三角形内部的纹理、深度、逐顶点的颜色与法线、Phongshading 逐像素的法线等 ......</p><p>可以说，三角形上的任何一种属性几乎都可以使用插值计算。</p></li><li><p><strong>如何使用重心坐标进行插值？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_14-48-02.png" style="zoom:33%;" /></p><p>三角形上的任意一个点 <spanclass="math inline">\((x,y)\)</span>，都可以用三个顶点的坐标的线性组合表示，并且满足线性组合的系数大于0且和为1，即满足：<span class="math display">\[\begin{align*}&amp; (x,y) = \alpha A+\beta B+\gamma C \\&amp; \alpha&gt;0,\beta&gt;0,\gamma&gt;0 \\&amp; \alpha+\beta+\gamma=1 \\\end{align*}\]</span>也就是说，我们描述三角形内的一个点的位置时，只要给定三角形三个顶点的坐标，就可以利用这三个坐标的线性组合，描述出这个点的位置在重心坐标下的表示。</p></li><li><p><strong>如何计算重心坐标？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_15-03-02.png" style="zoom:33%;" /></p><p>任意点的重心坐标是可以通过面积的比计算得到的。</p><p>如上图，三角形三个顶点的系数分别是该顶点所对三角形的面积占总面积的比值，即：<span class="math display">\[\begin{gather*}\alpha = \frac{A_A}{A_A+A_B+A_C} \\\beta = \frac{A_B}{A_A+A_B+A_C} \\\gamma = \frac{A_C}{A_A+A_B+A_C}\end{gather*}\]</span> 使用坐标简化计算，可得： <span class="math display">\[\begin{align*}&amp; \alpha =\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\\&amp; \\&amp; \beta =\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}   \\&amp; \\&amp; \gamma = 1 - \alpha - \beta\end{align*}\]</span><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_15-25-22.png" style="zoom: 33%;" /></p><p>与重心坐标相同，三角形内部任意一个点的属性也是可以通过三角形三个顶点的属性经过线性组合得到的。因此，我们可以直接使用该点重心坐标的系数，计算该点的插值。</p></li><li><p><strong>在投影变换下无法保证重心坐标不变</strong></p><p>在三维空间中的一些属性，经过投影变换到二维之后再进行重心坐标插值是无法保证其正确性的，这一点体现在深度的插值上。</p><p>如何解决这个问题呢？我们插值计算一个点的深度时，应该先使用逆变换回到三维空间中进行插值计算，再将计算结果返回。</p></li></ul><hr /><h3 id="applying-textures">2. Applying Textures</h3><ul><li><p><strong>如何将纹理应用到实时渲染中？</strong></p><p>在我们学习了重心坐标后，我们可以使用插值算出三角形内部任意一个点的纹理图坐标(u,v)，接着在纹理图中查找对应坐标的属性值。可以简单地描述为一下过程：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">for each rasterized screen sample (x, y):<br>  (u, v) = evaluate texture coordinate at (x, y);<br>  textcolor = texture.sample(u, v);<br>  set sample&#x27;s color to texcolor;<br></code></pre></td></tr></table></figure></li><li><p><strong>应用纹理图时遇到的问题</strong></p><p>屏幕的像素是 pixel ，纹理图的像素被称为 texel（纹素）。</p><ul><li><p>Texture Magnification（纹理的放大）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_16-01-39.png" style="zoom:38%;" /></p><p>当一个模型太大，它映射到屏幕上的像素多于纹理图的 texel时，会出现三角形顶点坐标映射到纹理图上时不是一个整数。为了正常进行纹理映射，我们对它进行近似到最近的一个整数值。但这么做会导致这个点包括它周围许多点都会映射到纹理图上的同一个坐标。</p><p>为了解决这个问题，我们应该找到一种别的办法，能够在查询非整数坐标时得到一个更加正确的值使其能够平滑地过渡。</p><ul><li><p><strong>Bilinear interpolation</strong>（双线性插值）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_16-49-30.png" style="zoom:75%;" /></p><p>假设有一个点映射到纹理图上的红点处，我们可以找出它临近的四个texel，并且定义其分别在水平方向上与texel的距离为<span class="math inline">\(s\)</span> 与垂直方向上的距离为 <spanclass="math inline">\(t\)</span>，再定义一个线性插值操作如下： <spanclass="math display">\[lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\]</span> 那么双线性插值如何操作呢？首先我们使用水平方向上的距离 <spanclass="math inline">\(s\)</span>对水平方向上的四个顶点进行线性插值：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_17-01-38.png" style="zoom:75%;" /><span class="math display">\[\begin{align*}&amp; u_0=lerp(s,u_{00},u_{10}) \\&amp; u_1=lerp(s,u_{01},u_{11})\end{align*}\]</span> 再使用垂直方向上的距离 <span class="math inline">\(t\)</span>对 <span class="math inline">\(u_0\)</span> 与 <spanclass="math inline">\(u_1\)</span> 进行插值： <spanclass="math display">\[f(x,y)=lerp(t,u_0,u_1)\]</span>这样计算得到的插值就会综合周围四个texel的数值，也就可以比较平滑地过渡了。</p></li><li><p>Bicubic</p><p>使用周围地16个texel进行较为复杂地三次插值，插值的效果更好。</p></li></ul></li><li><p>Texture Magnification</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_17-16-13.png" style="zoom: 50%;" /></p><p>图中对远处的模型进行简单地纹理映射后出现了摩尔纹而近处出现了锯齿，为什么？这是因为远处的模型太小而<strong>纹理图太大导致的走样</strong>。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_17-20-29.png" style="zoom:75%;" /></p><p>模型距离越远，每一个像素覆盖到的texel越多。当一个像素覆盖了多个texel，如果我们认为这个像素的值是它所覆盖的texel的平均值，这显然是不对的。在信号上可以理解为使用了一个采样点，去采样一个连续变化的信号（高频信号），这显然会引起走样问题。</p><p>那我们能否使用类似于MSAA的超采样算法解决这个问题呢？答案是可以的，但是会产生大量的开销。解决这个问题，我们还有更好的办法，那就是避免采样，直接做<strong>预处理</strong>，使我们可以直接知道某个范围内的平均值是多少。这样一来，问题就从一个点查询问题变成了一个范围查询问题。</p><ul><li><p><strong>Mipmap</strong></p><p>​ <strong>Mipmap能在方形区域内做快速的近似查询</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_17-38-16.png" style="zoom:75%;" /></p><p>Mipmap从原始图生成许多低分辨率的纹理图，每一层减少一半的像素，原始像素为<span class="math inline">\(n\times n\)</span> 的纹理图最多会由 <spanclass="math inline">\(\log{n}\)</span> 层。为了存储这些层，会产生额外<span class="math inline">\(\frac{1}{3}\)</span> 的存储开销。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_17-55-46.png" style="zoom:75%;" /></p><p>我们要在Mipmap中查询某个像素覆盖区域的平均值，那么我们应该先求出近似像素所覆盖的纹理图区域的方形边长是多少。假设我们有这么一个像素点，我们取它相邻两个像素，并将它们都投影到纹理图坐标系上。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_18-03-17.png" style="zoom:75%;" /></p><p>接着，我们计算这个像素点与相邻的两个坐标在纹理图坐标系上的距离分别是多少再取最大值，就可以近似出像素所覆盖的纹理图区域的方形边长是多少了。简单地说，我们做了一个将像素坐标上两个长度为1个单位的距离映射到纹理图坐标系中，并计算它们在纹理坐标系中长度应该是多少的操作。</p><p>那如何在Mipmap上查询边长为 L 的方形？很简单，如果 L等于1，那么我可以直接从原始图上找。那如果 L 等于 4 ？很显然，一个 4x4的texel会在第二层被Mipmap合并为一个texel。也就是说，对于一个 LxL的方形，他会在第 <span class="math inline">\(\log_2{L}\)</span>层被合并。</p><p>那么边长 L 与 平均值 D 的计算方法是：</p><figure><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20240122203902385.png"alt="image-20240122203902385" /><figcaption aria-hidden="true">image-20240122203902385</figcaption></figure><p>到目前为止，我们可以发现这些操作会产生一定的渐变效果，但是不连续。因为查询结果在不同层上的话就会破环连续性。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_18-37-28.png" /></p></li><li><p><strong>Trilinear Interpolation</strong>（三线性插值）</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_18-40-37.png" style="zoom:75%;" /></p><p>为了解决 Mipmap在层与层之间不连续的问题，我们需要在层间再做一次插值运算。也就是当一个像素投影到一个非整数边长的方形上时，我们在这个边长的相邻两层先分别做一次双线性插值，然后使用双线性插值的结果与这个非整数边长再做一次层与层之间的插值，近似地得到一个非整数层的结果。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_19-26-29.png" style="zoom:75%;" /></p></li><li><p>Mipmap会出现Overblur</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_19-28-22.png" style="zoom:75%;" /></p><p>为什么会出现overblur？Mipmap受限于只能近似得到方形区域的平均值，那如果像素的纹理覆盖区域不是方形呢？这会导致Mipmap近似出来的值与实际的值大相径庭。为了解决这个问题，我们需要新的预处理方法。</p></li><li><p>Anisotropic Filtering（各向异性过滤）</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_19-33-43.png" /></p><p>各向异性过滤在水平与竖直的两个方向上压缩原始图片，也就是说它可以快速查找到矩形覆盖区域的值。它会在原始图像的基础上多出3倍的存储开销。（显存够大就随便开）</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_19-36-11.png" /></p><p>各向异性过滤可以部分问题，但依旧不是完美的。</p></li><li><p>EWA Filtering（EWA过滤）</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-08_19-38-59.png" /></p><p>EWA过滤将任意一个不规则的覆盖区域拆解成许多个圆形的组合，通过<strong>多次查询</strong>这些圆形来得到覆盖区域的平均值。但EWA在时间上的开销明显要比Mipmap与各向异性过滤大了。</p></li></ul><hr /><h3 id="applications-of-textures">3. Applications of Textures</h3><ul><li><p><strong>Environment Map</strong> （环境光照贴图）</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_19-49-38.png" /></p><p>用纹理描述模型四周的环境光（假设环境光照都再无限远处，只记录方向信息），然后用纹理渲染模型。</p></li><li><p><strong>Spherical Environment Map</strong></p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_19-57-16.png" /></p><p>将环境光记录在球上，并将其展开：</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_19-58-30.png" /></p><p>会发现顶部（和底部）发生了扭曲（像世界地图一样），SphericalEnvironment Map 做到了描述球上的任何一个位置，但是它不均匀。</p></li><li><p><strong>Cube Map</strong></p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_20-02-01.png" /></p><p>还是这个球，用一个盒将其包围。对球面上每一个点P，从球心出发连到点P并继续延长直到到达盒上的某一个位置，在该位置记录下点P的信息。做完这些操作后，我们可以从盒上得到6张图，就像这样：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_20-10-28.png" style="zoom:80%;" /></p></li><li><p><strong>Bump mapping / normal mapping</strong>（凹凸贴图 /法线贴图）</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-19_20-15-39.png" /></p><p>凹凸贴图通过记录任意点对原模型的相对高度，使着色时法线方向发生改变，以在不改变模型复杂度的情况下实现凹凸的效果。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-22_14-34-19.png" style="zoom:50%;" /></p><p>如何计算新的法线？</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-22_14-43-01.png" style="zoom:50%;" /></p><p>假设在这个一维的凹凸贴图的变化函数中（flatland case）某点原本的法线<spanclass="math inline">\(n(p)=(0,1)\)</span>，计算该点在函数中的梯度（导数）<spanclass="math inline">\(dp=c*[h(p+1) - h(p)]\)</span>（系数 c决定凹凸贴图的影响大不大），可以求出该点上的切线 <spanclass="math inline">\(q=(1,dp)\)</span>，将切线逆时针旋转90度就可以得到新的法线<span class="math inline">\(n=(-dp,1).normalized()\)</span>.</p><p>将其推广到二维的凹凸贴图上，假设某点原本的法线 <spanclass="math inline">\(n(p)=(0,0,1)\)</span>，计算该点在 <spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 两个方向上的梯度： <spanclass="math display">\[\begin{gather*}dp/du=c1*[h[u+1]-h[u]]\\dp/dv=c2*[h[v+1]-h[v]]\end{gather*}\]</span> 同理，我们可以计算新的法线为： <span class="math display">\[n=(-dp/du,-dp/dv,1).normalized()\]</span> 但在实际应用中，原本的法线方向不可能总是 (0,0,1)，需要在局部定义一个坐标系 <span class="math inline">\((s,t,n)\)</span>使原本的法线方向为(0,0,1)，在这个局部坐标系中将新的法线方向计算出来后，再通过变换将新的法线方向重新映射回世界坐标中。</p></li><li><p><strong>Displacement mapping（位移贴图）</strong></p><p>位移贴图的输入与凹凸贴图完全一样，不同之处就在于位移贴图真的将位移量应用到了模型上，改变了模型的形状，会带来更好的效果。应用位移贴图要求模型足够精细，模型内三角形各顶点间的间隔要比纹理贴图上定义的频率还要高。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>着色器</tag>
      
      <tag>纹理图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture08 Shading 2</title>
    <link href="/2023/12/08/Games101-Lecture-08-Shading-2/"/>
    <url>/2023/12/08/Games101-Lecture-08-Shading-2/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/メア01.jpg" /></p><h1 id="shading-2">Shading 2</h1><h3 id="shading-frequencies">1. Shading Frequencies</h3><ul><li><p><strong>不同着色频率的着色方法</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_11-22-42.png" style="zoom: 33%;" /></p><p>​ 上图三种着色频率不同的着色方法分别是flat shading、Gouraud shading 与Phong shading；</p><ul><li><p>flat shading</p><p>​对每一个三角形求出其法线方向，根据法线、光照等得出三角形内部的一种着色方案并应用到整个三角形所覆盖的像素上，三角形内部的着色不会有任何变化。很明显flatshading的效果并不好。</p></li><li><p>Gouraud shading</p><p>​在任意一个顶点上，求出顶点的法线方向然后对顶点做一次着色。得出三角形三个顶点的着色后，利用插值将三角形内部覆盖的像素的着色计算出来。</p></li><li><p>Phong shading</p><p>​求出三角形三个顶点的法线方向后，对三角形所覆盖的每一个像素使用插值计算出它的法线方向，在对这个像素进行着色。</p></li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_17-18-15.png" style="zoom: 67%;" /></p><p>​ 当模型内三角形的数量接近像素的数量时，可以看出flatshading的效果也并不差。也就是说，着色频率本身也取决于模型内点或面出现的频率，当模型面数很高的情况下，不必要使用复杂的方式。但是在模型足够复杂的情况下，flatshading并不一定比其他模型快。</p></li><li><p><strong>如何计算顶点的法线？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_17-45-57.png" style="zoom:75%;" /></p><p>​一个简单的办法：一个顶点必定会是相邻多个三角形共同的顶点，那我们认为该顶点的法线就是相邻三角形的法线和求加权平均，权重可以是三角形的面积。</p></li><li><p><strong>如何计算逐像素的法线？</strong></p><p>​假设已经求出三角形顶点的法线，使用重心坐标计算出逐像素的法线（后面讲）。</p></li></ul><hr /><h3 id="graphics-real-time-rendering-pipeline">2. Graphics (Real-timeRendering) Pipeline</h3><ul><li><p><strong>什么是实时渲染管线?</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_20-30-04.png" style="zoom:67%;" /></p><p>​从场景到最后的一张图片中间经历的过程就是实时渲染管线(前面学过的所有过程)，他一般是被显卡等硬件定义好的，显卡会提供可编程的接口，可以自定义如何去着色。</p><p>​决定如何运作将这些顶点或像素着色的代码称为shader（着色器）。</p></li><li><p><strong>Shader Programs</strong></p><p>根据着色器的着色方法不同，可以将其分为 vertex shader 或 fragmentshader 等。</p><p>一个 openGL 的 GLSL fragment shader 示例程序：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl">unifrom <span class="hljs-type">sampler2D</span> myTexture;<br>unifrom <span class="hljs-type">vec3</span> lightDir;<br><span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> norm;<br><br><span class="hljs-type">void</span> diffuseShader()&#123;<br><span class="hljs-type">vec3</span> kd;<br>kd = texture2d(myTexture, uv);<span class="hljs-comment">//纹理</span><br>kd *= <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">dot</span>(-lightDir, norm), <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<span class="hljs-comment">//简化的Phong模型</span><br><span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(kd, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr /><h3 id="texture-mapping">3. Texture Mapping</h3><ul><li><p><strong>什么是纹理映射？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_23-37-12.png" style="zoom:75%;" /></p><p>​图中如何物体显示出不同的颜色？他们的基本区别是共用一个着色模型，但它们本身的漫反射模型系数发生了改变。为此我们希望有一种方法能够定义一个物体上的任何一个点它的属性。</p><p>​ <imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_23-41-13.png" /></p><p>​任何一个三维物体的表面都可以定义为一个二维的图。我们将物体表面任何一个点的属性映射到一张图中。反过来说，如果我们有一张纹理图，我们就可以定义一个物体上的任何一个点它的属性。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_23-44-05.png" /></p><p>为此，我们需要在纹理上定义一个坐标系。通常来说会定义 u 与 v两个坐标方向，并且都在 [0,1] 之间。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_23-50-38.png" style="zoom:67%;" /></p><p>有些纹理图可以被不断复制且四个方向都可以无缝衔接，这种纹理图被称为tiled textures 。</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_23-57-38.png" /></p><p>知道了每一个顶点对应的纹理图坐标后，我们如何知道三角形内部像素的属性呢？下节插值算法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>着色器</tag>
      
      <tag>纹理图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture07 Shading 1</title>
    <link href="/2023/12/07/Games101-Lecture-07-Shading-1/"/>
    <url>/2023/12/07/Games101-Lecture-07-Shading-1/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/天ノ川沙夜18-small.png" /></p><h1 id="shading-1">Shading 1</h1><h3 id="visibility">1. Visibility</h3><ul><li><p><strong>画家算法</strong></p><p>非常简单，就是从远到近绘制三角形。但是缺陷也很明显，三个三角形两两之间都存在覆盖关系时，画家算法就不能绘制正确的图形了。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_14-40-36.png" style="zoom: 50%;" /></p></li><li><p><strong>Z-buffering</strong></p><p>维护每个像素上深度最小的样本颜色，算法完成后会生成一副图存储深度信息与另一幅图存储目标图像。</p><ul><li>伪代码：</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">each</span> Triangle T)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">each</span> sample (x,y,z) <span class="hljs-keyword">in</span> T)&#123;<br><span class="hljs-keyword">if</span>(z &lt; zbuffer[x,y])&#123;<span class="hljs-comment">//找出目前最近的样本</span><br>framebuffer[x,y] = rgb;<span class="hljs-comment">//更新颜色</span><br>zbuffer[x,y] = z;<span class="hljs-comment">//更新深度</span><br>&#125;<br><span class="hljs-keyword">else</span><br>;<span class="hljs-comment">//什么都不做</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_14-57-31.png" style="zoom:50%;" /></p><ul><li>时间复杂度为O(n)</li></ul></li></ul><hr /><h3 id="shading">2. Shading</h3><ul><li><p><strong>什么是着色？</strong></p><p>对不同的物体应用不同材质的过程。</p></li><li><p><strong>基础的着色模型——Blnn-Phong 反射模型（Blnn-PhongReflectance Model）</strong></p><p>一般来说，我们看一个物体的光照大致可以分成三部分：高光（Specularhighlights）、漫反射（Diffuse reflection）、环境光（Ambientlighting）。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_15-08-34.png" style="zoom:50%;" /></p><ul><li><p>inputs：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_15-11-14.png" style="zoom:50%;" /></p><p>假设在每一个极小的点（shading point）上都是平面，在此平面上定义：</p><ul><li>观察方向：从shading point到相机的方向向量 <spanclass="math inline">\(\overrightarrow{v}\)</span> ；</li><li>法向量：垂直于shading point所在平面的方向法向量 <spanclass="math inline">\(\overrightarrow{n}\)</span> ；</li><li>光照方向：从shading point到光源的方向向量 <spanclass="math inline">\(\overrightarrow{l}\)</span> ；</li><li>表面材质：颜色、光泽 . . .</li></ul></li><li><p>漫反射（Diffuse reflection）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_15-21-20.png" style="zoom:50%;" /></p><p>一个物体表面的法线 <spanclass="math inline">\(\overrightarrow{n}\)</span> 与光照方向 <spanclass="math inline">\(\overrightarrow{l}\)</span> 的夹角 <spanclass="math inline">\(\theta\)</span> 决定了该物体表面的亮度。</p><p>夹角 <span class="math inline">\(\theta\)</span>决定了该平面能够接收到光照的面积，shadingpoint周围单位面积所能接收到的能量为 <spanclass="math inline">\(\overrightarrow{n}\cdot\overrightarrow{l}\)</span>。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_15-29-38.png" style="zoom: 33%;" /></p><p>我们认为，如果一个点光源在任意时刻向任意方向发出相同的能量，那么这些能量一定集中在一个所谓的球壳上，且每个球壳上的能量总和都是相等的。当球壳与点光源的距离越远，球壳的面积越大，所以球壳上单位面积所蕴含的能量就越小。</p><p>假设距离点光源单位距离的球壳上单位面积光照强度为 <spanclass="math inline">\(I\)</span>，则距离 <spanclass="math inline">\(r\)</span> 的球壳上单位面积光照强度为 <spanclass="math inline">\(I/r^2\)</span> 。</p><p>由以上两点，我们可以知道shading point接收到漫反射的能量为： <spanclass="math display">\[L_d=k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})\]</span> 其中 <span class="math inline">\(K_d\)</span> 由shadingpoint的材质决定：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_15-43-18.png" style="zoom:50%;" /></p><p>漫反射与观察方向 <spanclass="math inline">\(\overrightarrow{v}\)</span>没有任何关系。</p></li><li><p>高光（Specular highlights）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-05_16-00-09.png" style="zoom:50%;" /></p><p>什么时候会看到高光呢？简单的说，如果一个物体足够光滑，那么高光会在光线的出射方向附近有一定范围的分布，当观察方向在这个分布范围内时，可以观察到高光。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_09-57-42.png" style="zoom: 50%;" /></p><p>我们可以观察到，当观察方向 <spanclass="math inline">\(\overrightarrow{v}\)</span>与光线的出射方向接近时，说明半程向量 <spanclass="math inline">\(\overrightarrow{h}\)</span> 和 法线方向 <spanclass="math inline">\(\overrightarrow{n}\)</span>很接近。利用向量的点乘，我们可以判断两个向量是否接近。根据这两点我们可以简化高光的计算方式为：<span class="math display">\[\begin{gather*}\overrightarrow{h}=bisector(v,l)=\frac{v+l}{\|v+l\|} \\L_s=k_s(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p\end{gather*}\]</span> 为什么需要指数 <span class="math inline">\(p\)</span>？因为直接使用点乘计算的结果容忍度太高，会导致高光分布范围太大，高光边缘不明显。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_10-26-19.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-07_10-29-21.png" style="zoom:50%;" /></p><p>为什么不考虑物体的角度对高光的影响？Blnn-Phong模型是一个简单的经验模型，实际上是需要的。</p></li><li><p>环境光（Ambient lighting）</p><p>Blnn-Phong模型对环境光非常简化，仅考虑环境光常数系数 <spanclass="math inline">\(I_a\)</span> <span class="math display">\[L_a=k_aI_a\]</span> 事实上的环境光模型十分复杂。</p></li><li><p>总的来说，Blnn-Phong反射模型的算式为： <spanclass="math display">\[\begin{gather*}L=L_a+L_d+L_s\\=k_aI_a+k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})+max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p\end{gather*}\]</span></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>着色器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - 作业1代码及框架分析</title>
    <link href="/2023/12/05/Games101-%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2023/12/05/Games101-%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/魔女恋にっき＿花音2-small.png" /></p><ul><li>作业1做的是完成 get_model_matrix() 和 get_projection_matrix()函数，只要计算和返回两个变换矩阵就可以了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_model_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> rotation_angle)</span></span><br><span class="hljs-function"></span>&#123;<br>    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the model matrix for rotating the triangle around the Z axis.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    <span class="hljs-type">float</span> sin_rotation_angle = <span class="hljs-built_in">sin</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    <span class="hljs-type">float</span> cos_rotation_angle = <span class="hljs-built_in">cos</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    model &lt;&lt;<br>    cos_rotation_angle, -sin_rotation_angle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    sin_rotation_angle, cos_rotation_angle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> model;<br>&#125;<br><br><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_projection_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> eye_fov, <span class="hljs-type">float</span> aspect_ratio,<span class="hljs-type">float</span> zNear, <span class="hljs-type">float</span> zFar)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Students will implement this function</span><br><br>    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the projection matrix for the given parameters.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    <span class="hljs-comment">// Matrix for M_persp -&gt; M_troho</span><br>    Eigen::Matrix4f M_persp_troth = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_persp_troth &lt;&lt; zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zNear + zFar, -(zNear * zFar),<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// value of l,f,t,b;</span><br>    <span class="hljs-type">float</span> top, bottom, left, right;<br>    top = <span class="hljs-built_in">tan</span>(eye_fov / <span class="hljs-number">2</span>) * <span class="hljs-built_in">abs</span>(zNear);<br>    bottom = (<span class="hljs-number">-1</span>) * top;<br>    right = aspect_ratio * top;<br>    left = (<span class="hljs-number">-1</span>) *right;<br><br>    <span class="hljs-comment">// Matrix for move to origin.</span><br>    Eigen::Matrix4f M_move = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_move &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">-1</span>) * (left + right) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">-1</span>) * (top + bottom) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (<span class="hljs-number">-1</span>) * (zNear +  zFar) / <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Matrix for scale.</span><br>    Eigen::Matrix4f M_scale = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_scale &lt;&lt;<br>    <span class="hljs-number">2</span> / (right - left), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (top - bottom), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (zNear - zFar), <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Matrix for ortho transformation.</span><br>    Eigen::Matrix4f M_ortho = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    M_ortho = M_scale * M_move;<br><br>    projection = M_ortho * M_persp_troth;<br><br>    <span class="hljs-keyword">return</span> projection;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>再来简单分析一下光栅器的代码，先从main入手：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> angle = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> command_line = <span class="hljs-literal">false</span>;<br>    std::string filename = <span class="hljs-string">&quot;output.png&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        command_line = <span class="hljs-literal">true</span>;<br>        angle = std::<span class="hljs-built_in">stof</span>(argv[<span class="hljs-number">2</span>]); <span class="hljs-comment">// -r by default</span><br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">4</span>) &#123;<br>            filename = std::<span class="hljs-built_in">string</span>(argv[<span class="hljs-number">3</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 定义一个700x700的光栅器，构造函数会根据参数创建二维数组frame_buf和deepth_buf</span><br>    <span class="hljs-function">rst::rasterizer <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>)</span></span>;<br>    <span class="hljs-comment">// 相机朝向的向量</span><br>    Eigen::Vector3f eye_pos = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 三角形的三个顶点坐标</span><br>    std::vector&lt;Eigen::Vector3f&gt; pos&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 应该是三角形的id，值的意义是对应的三个顶点在向量中的下标</span><br>    std::vector&lt;Eigen::Vector3i&gt; ind&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    rst::pos_buf_id rst::rasterizer::load_positions(const std::vector&lt;Eigen::Vector3f&gt; &amp;positions)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        auto id = get_next_id();</span><br><span class="hljs-comment">        pos_buf.emplace(id, positions);</span><br><span class="hljs-comment">        return &#123;id&#125;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    pos_buf是一个map，这个函数作用是为每个三角形坐标的顶点信息指定一个id，并存到下标为id的map中，最后返回该id</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">auto</span> pos_id = r.<span class="hljs-built_in">load_positions</span>(pos);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    rst::ind_buf_id rst::rasterizer::load_indices(const std::vector&lt;Eigen::Vector3i&gt; &amp;indices)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        auto id = get_next_id();</span><br><span class="hljs-comment">        ind_buf.emplace(id, indices);</span><br><span class="hljs-comment">        return &#123;id&#125;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    迷惑，为什么要这么写</span><br><span class="hljs-comment">    功能和load_positions类似，只不过换成了存储和标记下标</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-comment">//关于这两个函数如何工作详见draw方法</span><br>    <span class="hljs-keyword">auto</span> ind_id = r.<span class="hljs-built_in">load_indices</span>(ind);<br><br><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> frame_count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (command_line) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        void rst::rasterizer::clear(rst::Buffers buff)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if ((buff &amp; rst::Buffers::Color) == rst::Buffers::Color)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                std::fill(frame_buf.begin(), frame_buf.end(), Eigen::Vector3f&#123;0, 0, 0&#125;);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            if ((buff &amp; rst::Buffers::Depth) == rst::Buffers::Depth)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                std::fill(depth_buf.begin(), depth_buf.end(), std::numeric_limits&lt;float&gt;::infinity());</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        Buffers是一个枚举类型，clear函数的功能是如果深度或颜色参数与该枚举类中的值一样，则将深度无限大或颜色设置为(0,0,0)</span><br><span class="hljs-comment">        使用这个枚举类型以达到初始化frame_buf与depth_buf的目的</span><br><span class="hljs-comment">        */</span><br>        r.<span class="hljs-built_in">clear</span>(rst::Buffers::Color | rst::Buffers::Depth);<br><br>        <span class="hljs-comment">// 设置变换矩阵</span><br>        r.<span class="hljs-built_in">set_model</span>(<span class="hljs-built_in">get_model_matrix</span>(angle));<br>        r.<span class="hljs-built_in">set_view</span>(<span class="hljs-built_in">get_view_matrix</span>(eye_pos));<br>        <span class="hljs-comment">// 这里设置了光锥的fovY为45，aspect为1(700x700)，n为0.1与f为50，可以尝试修改观察变化</span><br>        r.<span class="hljs-built_in">set_projection</span>(<span class="hljs-built_in">get_projection_matrix</span>(<span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">50</span>));<br><br>        <span class="hljs-comment">// draw函数绘制三角形</span><br>        r.<span class="hljs-built_in">draw</span>(pos_id, ind_id, rst::Primitive::Triangle);<br>        <span class="hljs-function">cv::Mat <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>, CV_32FC3, r.frame_buffer().data())</span></span>;<br>        image.<span class="hljs-built_in">convertTo</span>(image, CV_8UC3, <span class="hljs-number">1.0f</span>);<br><br>        cv::<span class="hljs-built_in">imwrite</span>(filename, image);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 与上面的方法一样</span><br>    <span class="hljs-keyword">while</span> (key != <span class="hljs-number">27</span>) &#123;<br><br>        r.<span class="hljs-built_in">clear</span>(rst::Buffers::Color | rst::Buffers::Depth);<br><br>        r.<span class="hljs-built_in">set_model</span>(<span class="hljs-built_in">get_model_matrix</span>(angle));<br>        r.<span class="hljs-built_in">set_view</span>(<span class="hljs-built_in">get_view_matrix</span>(eye_pos));<br>        r.<span class="hljs-built_in">set_projection</span>(<span class="hljs-built_in">get_projection_matrix</span>(<span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">50</span>));<br><br>        r.<span class="hljs-built_in">draw</span>(pos_id, ind_id, rst::Primitive::Triangle);<br><br>        <span class="hljs-function">cv::Mat <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">700</span>, <span class="hljs-number">700</span>, CV_32FC3, r.frame_buffer().data())</span></span>;<br>        image.<span class="hljs-built_in">convertTo</span>(image, CV_8UC3, <span class="hljs-number">1.0f</span>);<br>        cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;T_image&quot;</span>, image);<br>        key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">10</span>);<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;frame count: &quot;</span> &lt;&lt; frame_count++ &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            angle += <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;d&#x27;</span>) &#123;<br>            angle -= <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>draw函数功能是绘制三角形线框</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">draw</span>(rst::pos_buf_id pos_buffer, rst::ind_buf_id ind_buffer, rst::Primitive type)<br>&#123;<br>    <span class="hljs-keyword">if</span> (type != rst::Primitive::Triangle)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Drawing primitives other than triangle is not implemented yet!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据参数获得id</span><br>    <span class="hljs-keyword">auto</span>&amp; buf = pos_buf[pos_buffer.pos_id];<br>    <span class="hljs-keyword">auto</span>&amp; ind = ind_buf[ind_buffer.ind_id];<br><br>    <span class="hljs-comment">// 没用到不知道是干什么的</span><br>    <span class="hljs-type">float</span> f1 = (<span class="hljs-number">100</span> - <span class="hljs-number">0.1</span>) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-type">float</span> f2 = (<span class="hljs-number">100</span> + <span class="hljs-number">0.1</span>) / <span class="hljs-number">2.0</span>;<br><br>    <span class="hljs-comment">// 计算mvp变换矩阵</span><br>    Eigen::Matrix4f mvp = projection * view * model;<br>    <span class="hljs-comment">// 遍历每一个存储的ind</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : ind)<br>    &#123;<br>        Triangle t;<br><br>        <span class="hljs-comment">// 每个点做mvp变换</span><br>        Eigen::Vector4f v[] = &#123;<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">0</span>]], <span class="hljs-number">1.0f</span>),<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">1</span>]], <span class="hljs-number">1.0f</span>),<br>                mvp * <span class="hljs-built_in">to_vec4</span>(buf[i[<span class="hljs-number">2</span>]], <span class="hljs-number">1.0f</span>)<br>        &#125;;<br><br>        <span class="hljs-comment">// 归一化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; vec : v) &#123;<br>            vec /= vec.<span class="hljs-built_in">w</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 变换到屏幕空间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; vert : v)<br>        &#123;<br>            vert.<span class="hljs-built_in">x</span>() = <span class="hljs-number">0.5</span>*width*(vert.<span class="hljs-built_in">x</span>()+<span class="hljs-number">1.0</span>);<br>            vert.<span class="hljs-built_in">y</span>() = <span class="hljs-number">0.5</span>*height*(vert.<span class="hljs-built_in">y</span>()+<span class="hljs-number">1.0</span>);<br>            vert.<span class="hljs-built_in">z</span>() = vert.<span class="hljs-built_in">z</span>() * f1 + f2;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置三个顶点的坐标，从每个齐次坐标中取前三个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>        &#123;<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>            t.<span class="hljs-built_in">setVertex</span>(i, v[i].<span class="hljs-built_in">head</span>&lt;<span class="hljs-number">3</span>&gt;());<br>        &#125;<br><br><br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255.0</span>,  <span class="hljs-number">0.0</span>,  <span class="hljs-number">0.0</span>);<br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>  ,<span class="hljs-number">255.0</span>,  <span class="hljs-number">0.0</span>);<br>        t.<span class="hljs-built_in">setColor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0.0</span>  ,  <span class="hljs-number">0.0</span>,<span class="hljs-number">255.0</span>);<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        void rst::rasterizer::rasterize_wireframe(const Triangle&amp; t)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            draw_line(t.c(), t.a());</span><br><span class="hljs-comment">            draw_line(t.c(), t.b());</span><br><span class="hljs-comment">            draw_line(t.b(), t.a());</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 光栅化三条线段，这个应该很好算</span><br>        <span class="hljs-built_in">rasterize_wireframe</span>(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>光栅器中使用了draw_line方法绘制线段，使用了由Bresenham提出的一种精确而有效的光栅线生成算法<strong>Bresenham'slinealgorithm</strong>，可用于显示线、圆和其他曲线的整数增量运算，是目前最有效的线段生成算法，推导可见：<ahref="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham'slinealgorithm wiki</a></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">draw_line</span>(Eigen::Vector3f begin, Eigen::Vector3f end)<br>&#123;<br>    <span class="hljs-keyword">auto</span> x1 = begin.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-keyword">auto</span> y1 = begin.<span class="hljs-built_in">y</span>();<br>    <span class="hljs-keyword">auto</span> x2 = end.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-keyword">auto</span> y2 = end.<span class="hljs-built_in">y</span>();<br><br>    Eigen::Vector3f line_color = &#123;<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;;<br><br>    <span class="hljs-type">int</span> x,y,dx,dy,dx1,dy1,px,py,xe,ye,i;<br><br>    dx=x2-x1;<br>    dy=y2-y1;<br>    dx1=<span class="hljs-built_in">fabs</span>(dx);<br>    dy1=<span class="hljs-built_in">fabs</span>(dy);<br>    px=<span class="hljs-number">2</span>*dy1-dx1;<br>    py=<span class="hljs-number">2</span>*dx1-dy1;<br><br>    <span class="hljs-keyword">if</span>(dy1&lt;=dx1)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dx&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            x=x1;<br>            y=y1;<br>            xe=x2;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            x=x2;<br>            y=y2;<br>            xe=x1;<br>        &#125;<br>        Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;x&lt;xe;i++)<br>        &#123;<br>            x=x+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(px&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                px=px+<span class="hljs-number">2</span>*dy1;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((dx&lt;<span class="hljs-number">0</span> &amp;&amp; dy&lt;<span class="hljs-number">0</span>) || (dx&gt;<span class="hljs-number">0</span> &amp;&amp; dy&gt;<span class="hljs-number">0</span>))<br>                &#123;<br>                    y=y+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    y=y<span class="hljs-number">-1</span>;<br>                &#125;<br>                px=px+<span class="hljs-number">2</span>*(dy1-dx1);<br>            &#125;<br><span class="hljs-comment">//            delay(0);</span><br>            Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dy&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            x=x1;<br>            y=y1;<br>            ye=y2;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            x=x2;<br>            y=y2;<br>            ye=y1;<br>        &#125;<br>        Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;y&lt;ye;i++)<br>        &#123;<br>            y=y+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(py&lt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                py=py+<span class="hljs-number">2</span>*dx1;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((dx&lt;<span class="hljs-number">0</span> &amp;&amp; dy&lt;<span class="hljs-number">0</span>) || (dx&gt;<span class="hljs-number">0</span> &amp;&amp; dy&gt;<span class="hljs-number">0</span>))<br>                &#123;<br>                    x=x+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    x=x<span class="hljs-number">-1</span>;<br>                &#125;<br>                py=py+<span class="hljs-number">2</span>*(dx1-dy1);<br>            &#125;<br><span class="hljs-comment">//            delay(0);</span><br>            Eigen::Vector3f point = Eigen::<span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-built_in">set_pixel</span>(point,line_color);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>提高</strong></p><p>直接套用讲过的<strong>罗德里格斯旋转公式</strong>： <spanclass="math display">\[\mathbf{R}(\mathbf{n},\alpha)=\cos(\alpha)~\mathbf{I} + (1-\cos(\alpha))~\mathbf{n}\mathbf{n}^T +\sin\alpha~\underbrace{\begin{pmatrix}  0 &amp; -n_z &amp; -n_y \\  n_z &amp; 0 &amp; -n_x \\  -n_y &amp; n_x &amp; 0\end{pmatrix} }_{\mathbf{N} }\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_model_matrix</span><span class="hljs-params">(Eigen::Vector4f rotation_axis, <span class="hljs-type">float</span> rotation_angle)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> sin_rotation_angle = <span class="hljs-built_in">sin</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    <span class="hljs-type">float</span> cos_rotation_angle = <span class="hljs-built_in">cos</span>(rotation_angle / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>));<br>    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    Eigen::Matrix4f I = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    Eigen::Matrix4f N;<br>    N &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> * rotation_axis.<span class="hljs-built_in">z</span>(), rotation_axis.<span class="hljs-built_in">y</span>(), <span class="hljs-number">0</span>,<br>        rotation_axis.<span class="hljs-built_in">z</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> * rotation_axis.<span class="hljs-built_in">x</span>(), <span class="hljs-number">0</span>,<br>        <span class="hljs-number">-1</span> * rotation_axis.<span class="hljs-built_in">y</span>(), rotation_axis.<span class="hljs-built_in">x</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>    <br>    model = cos_rotation_angle * I + (<span class="hljs-number">1</span> - cos_rotation_angle) * rotation_axis * rotation_axis.<span class="hljs-built_in">transpose</span>() + sin_rotation_angle * N;<br>    <span class="hljs-built_in">model</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> model;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>MVP变换</tag>
      
      <tag>光栅化</tag>
      
      <tag>代码实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_debug</title>
    <link href="/2023/12/05/hexo-debug/"/>
    <url>/2023/12/05/hexo-debug/</url>
    
    <content type="html"><![CDATA[<h4id="记录一下hexo使用过程中遇到的的bug以及解决方法">记录一下hexo使用过程中遇到的的bug以及解决方法</h4><ul><li><p><strong>render LateX公式过程出现错误：parseAggregate: expectedcomma after expression</strong></p><p>Google后发现是LateX公式中要将 '{' 或 '}'符号中间用空格隔开...</p></li></ul><hr /><p>持续更新中....</p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture06 Rasterization 2 (Antialiasing)</title>
    <link href="/2023/11/30/Games101-Lecture-06-Rasterization-2-Antialiasing/"/>
    <url>/2023/11/30/Games101-Lecture-06-Rasterization-2-Antialiasing/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/aokana01-small.png" /></p><h1 id="rasterization-2-antialiasing-and-z-buffering">Rasterization 2(Antialiasing and Z-Buffering)</h1><h3 id="sampling-artifacts">1. Sampling Artifacts</h3><ul><li><p><strong>什么是 Artifacts ？</strong></p><p>在计算机图形中的错误（Errors）、错误（Mistakes）、不准确（Inaccuracies）。</p></li><li><p><strong>常见的 Artifacts 有哪些？</strong></p><ul><li>锯齿（Jaggies）：空间采样</li><li>摩尔纹（Moire）：图形欠采样</li><li>车轮效应（Wagon wheel effect）：及时采样</li><li>还有很多......</li></ul></li><li><p><strong>为什么会产生这些 Artifacts ?</strong></p><p>信号变化太快（高频）但是采样速度太慢。</p></li><li><p><strong>如何解决这些问题？</strong></p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-11-30_11-07-29.png" style="zoom: 67%;" /></p><p>在<strong>进行采样之前，对信号进行处理</strong>可以达到解决问题的效果。</p></li></ul><hr /><h3 id="frequency-domain">2. Frequency Domain</h3><ul><li><p><strong>什么是走样？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-30_16-44-30.png" style="zoom: 67%;" /></p><p>图示两个截然不同的函数，在相同采样方式下的采样结果却完全相同。</p><p><strong>同样的一种采样方法，采样两种频率不同的函数，得出的结果我们无法区分，这就是走样。</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-30_17-31-09.png" style="zoom: 67%;" /></p><p>图示5个周期函数中我们可以看到，当函数频率越高时，采样后的结果与原函数的区别越明显。</p><p>也就是说，越高的频率需要越快的采样。</p></li><li><p><strong>什么是傅里叶展开？</strong></p><p>任何一个周期函数，都可以将其写成一系列正弦与余弦函数的线性组合以及一个常数项。</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-11-30_11-18-50.png" style="zoom: 50%;" /><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-11-30_11-19-51.png" style="zoom: 50%;" /></p><p>图示函数使用傅里叶展开： <span class="math display">\[f(x)=\frac{A}{2}+\frac{2A\cos{t\omega}}{\pi}+\frac{2A\cos{3t\omega}}{3\pi}+\frac{2A\cos{5t\omega}}{5\pi}+\frac{2A\cos{7t\omega}}{7\pi}+ ...\]</span> 每添加一项，都能更加逼近原函数。</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-11-30_16-57-10.png" style="zoom: 67%;" /></p><p>使用傅里叶变换可以得到这些展开的项。</p></li><li><p><strong>什么是傅里叶变换？</strong></p><p>所谓傅里叶变换，就是将函数分解为不同频率的段，并将这些段显示出来。</p><p>简单地讲，傅里叶变换可以将一个函数从时域变换到频域。</p><p>通过傅里叶变换，我们可以看到任何信号在不同的频域长什么样，也就是频谱。</p></li></ul><hr /><h3 id="filtering-convolution-averaging">3. Filtering = Convolution ( =Averaging)</h3><ul><li><p><strong>什么是滤波？</strong></p><p>将信号中特定的频段抹除后，对应的信号应发生什么变化。</p><ul><li><p>一张图片与其对应的频谱：</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_14-35-52.png" style="zoom: 50%;" /></p></li><li><p>经过高通滤波后的图像，仅保留了高频的信息（物体边界）：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-01_14-38-44.png" style="zoom: 50%;" /></p></li></ul></li><li><p><strong>什么是卷积？</strong></p><ul><li><p>如何做卷积（图形学上）：</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_14-46-50.png" style="zoom: 67%;" /></p><p>将每个信号对应的段与滤波进行点乘，点乘的结果是该段的中心卷积后的值。</p></li><li><p>卷积的定理</p><ul><li>两个信号在时域上的卷积等于这两个信号在频域上的乘积，反之亦然；</li><li>卷积的结果等于将信号傅里叶变换到频域上乘积后再逆傅里叶变换到时域的结果；</li></ul></li></ul></li><li><p><strong>卷积的使用</strong></p><ul><li><p>模糊处理</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_14-58-50.png" style="zoom: 67%;" /></p><p>模糊处理的卷积核是一个低通滤波器，卷积核越大，模糊处理效果越明显。</p></li></ul></li></ul><hr /><h3 id="sampling-in-frequency-domaitn">4. Sampling in FrequencyDomaItn</h3><ul><li><p><strong>什么是采样（从频域上看）？</strong></p><p>采样就是在重复频域上的内容。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-01_15-11-11.png"  /></p><p>​将信号与冲激函数进行傅里叶变换后，计算二者的乘积，可以看出采样就是在重复频域上的内容，这是因为在时域中以固定间隔采样相当于在频域中以相邻频率间隔复制原始频谱。</p></li><li><p><strong>什么是走样（从频域上看）？</strong></p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-01_15-22-35.png" /></p><p>因为采样的速度不够快，采样时复制原始频谱的间隔太小，复制的频谱之间太密集导致频谱混叠在一起。</p></li></ul><hr /><h3 id="antialiasing">5. Antialiasing</h3><ul><li><p><strong>终极办法——增加采样率</strong></p><p>​当屏幕上的像素点越密集，像素越多，采样率越快，频谱上表现为相邻复制频谱的间隔变大，就可以从根本上解决走样问题，但也受到物理限制。</p></li><li><p><strong>反走样（抗锯齿）</strong></p><ul><li><p>MSAA（Antialiasing By Supersampling）</p><p><imgsrc="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_15-49-15.png" /></p><p>将原始图像进行模糊处理，即将原始频谱变短（去掉高频），可以有效地防止发生混叠。</p><p><imgsrc="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-11-30_11-07-29.png" /></p><p>那么如何对图像进行模糊处理呢？</p><ul><li><p>模糊操作（卷积）：用每一个像素对应的box做卷积操作，根据得到平均值填充该像素</p><p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-01_15-57-30.png" /></p><p>将一个像素内部划分为很多个小像素，增加其采样点，通过计算小像素被三角形覆盖的数量，计算三角形在每个像素中的覆盖率：</p><p><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_16-12-08.png" style="zoom:50%;" /><img src="G:\exe\OneDrive\Person\OneDrive\Note\Games101\src\Snipaste_2023-12-01_16-08-53.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-12-01_16-17-23.png" style="zoom:80%;" /></p><p><strong>通过MSAA只能提高三角形在每个像素中的覆盖率的计算精确度，并没有实际提高采样率。</strong></p></li><li><p>使用MSAA的代价：将像素细分必将带来很多的计算量。但MSAA在实际应用中并不会只是单纯细分为规则的像素点，相邻的像素点间也可能复用，因此MSAA的效率也并不是那么低。</p></li></ul></li><li><p>FXAA（Fast Approximate AA）</p><p>快速近似抗锯齿的方法是先得到一幅带锯齿的图像，再通过图像匹配的方式找到有锯齿的边界，再将其换成不带锯齿的边界。FXAA与采样无关，是一种在图像层面的抗锯齿方法。</p></li><li><p>TAA（Temporal AA）</p><p>TAA的方法是在同一像素的不同帧内采用不同位置的采样，并在后来的帧内复用这些采样。相当于将MSAA对应的样本给分布到了时间上，并且当前帧不做额外操作（静态）。</p></li></ul></li><li><p>超分辨率</p><p>将一副采样率不足的高分辨率图像缺失的采样恢复出来。</p><p>DLSS（Deep Learning SuperSampling）：采用深度学习将缺失的采样恢复。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>光栅化</tag>
      
      <tag>反走样</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture05 Rasterization 1 (Triangles)</title>
    <link href="/2023/11/28/Games101-Lecture-05-Rasterization-1-Triangles/"/>
    <url>/2023/11/28/Games101-Lecture-05-Rasterization-1-Triangles/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/メアリー03-small.png" /></p><h1 id="rasterization-1-triangles">Rasterization 1 (Triangles)</h1><h3 id="canonical-cube-to-screen">1. Canonical Cube to Screen</h3><ul><li><p><strong>什么是屏幕？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_15-36-39.png" style="zoom:33%;" /></p><p>屏幕一般被定义为一个二维数组，从(0,0)开始，每个像素的坐标是其所在方块的左下角的坐标值。</p></li><li><p><strong>如何将标准立方体映射到屏幕上？(视口变换)</strong></p><ul><li><p>改变换与Z轴无关；</p></li><li><p>将 <span class="math inline">\([-1,1]^2\)</span> 变换到 <spanclass="math inline">\([0,width]\times[0,height]\)</span> ： <spanclass="math display">\[M_{viewport}=\begin{pmatrix}    \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\    0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\    0 &amp; 0 &amp; 1 &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li></ul></li></ul><h3 id="triangles-meshes">2. Triangles MEshes</h3><ul><li><p><strong>为什么三角形会在图形学中得到广泛应用？</strong></p><ul><li>三角形是最基本的多边形；</li><li>可以将其他多边形分解为三角形；</li><li>三角形内部一定是平面的；</li><li>三角形内外的定义十分清晰；</li><li>定义三角形三个顶点的属性，可以有规律地对三角形内部地点地属性进行插值（重心插值）；</li></ul></li><li><p>一种简单的光栅化的方法：采样</p><ul><li><p><strong>什么是采样？</strong></p><p>给定一个连续的函数，对任意一个点询问该点的函数值是多少。采样是将一个函数离散化的过程。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-30_10-08-14.png" style="zoom: 25%;" /><spanclass="math inline">\(\Rightarrow\)</span><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-30_10-11-00.png" style="zoom:25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; xmax; x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; ymax; y++)&#123;<br>image[x][y] = <span class="hljs-built_in">inside</span>(tri, x + <span class="hljs-number">0.5</span>, y + <span class="hljs-number">0.5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Bounding Box!</strong> （AABB）</p><p>采样时有许多优化方式，最简单的一种就是 BoundingBox，通过三个顶点的坐标判断循环的范围，减少无效计算。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-30_10-16-58.png" style="zoom:25%;" /></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>光栅化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture04 Transformation Cont</title>
    <link href="/2023/11/27/Games101-Lecture-04-Transformation-Cont/"/>
    <url>/2023/11/27/Games101-Lecture-04-Transformation-Cont/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/shion1-small.png" /></p><h1 id="transformation">Transformation</h1><h3 id="d-modeling-transformation">1. 3D Modeling Transformation</h3><ul><li><p><strong>简单的三维变换</strong></p><ul><li><p>缩放 <span class="math display">\[S(s_x,s_y,s_z)=\begin{pmatrix}    s_x &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; s_y &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; s_z &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li><li><p>平移 <span class="math display">\[T(t_x,t_y,t_z)=\begin{pmatrix}    1 &amp; 0 &amp; 0 &amp; t_x \\    0 &amp; 1 &amp; 0 &amp; t_y \\    0 &amp; 0 &amp; 1 &amp; t_z \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li><li><p>简单绕轴旋转 <span class="math display">\[R_x(\alpha)=\begin{pmatrix}    1 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; \cos\alpha &amp; -\sin\alpha &amp; 0 \\    0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p><span class="math display">\[R_y(\alpha)=\begin{pmatrix}    \cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 \\    -\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p><span class="math display">\[R_z(\alpha)=\begin{pmatrix}    \cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\    \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p></li></ul></li><li><p><strong>罗德里格斯旋转公式 (Rodrigues' RotationFormula)</strong></p><p>定义一个旋转角度 <span class="math inline">\(\alpha\)</span>与一条经过原点的旋转轴 <spanclass="math inline">\(\mathbf{n}\)</span>，则 <spanclass="math display">\[\mathbf{R}(\mathbf{n},\alpha)=\cos(\alpha)~\mathbf{I} + (1-\cos(\alpha))~\mathbf{n}\mathbf{n}^T +\sin\alpha~\underbrace{\begin{pmatrix}  0 &amp; -n_z &amp; -n_y \\  n_z &amp; 0 &amp; -n_x \\  -n_y &amp; n_x &amp; 0\end{pmatrix} }_{\mathbf{N} }\]</span></p></li></ul><hr /><h3 id="viewing-transformation">2. Viewing transformation</h3><ul><li><p><strong>View / Camera transformation</strong></p><p>如何进行视图变换？</p><ul><li><p>定义相机：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-27_10-20-49.png" style="zoom: 33%;" /></p><ul><li>位置 <span class="math inline">\(\overrightarrow{e}\)</span></li><li>朝向 <span class="math inline">\(\hat{g}\)</span></li><li>向上的方向 <span class="math inline">\(\hat{t}\)</span></li></ul></li><li><p>为了简化变换，我们可以使相机与模型的相对位置不变，固定相机位置：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-27_10-31-54.png" style="zoom:38%;" /></p><ul><li><p>移动并固定相机位置在原点</p></li><li><p>旋转并固定相机为以Y轴为向上方向</p></li><li><p>旋转并固定相机朝向-Z</p></li><li><p>同时变换除相机以外的模型</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-27_10-37-07.png" style="zoom:33%;" /></p></li></ul><p>由于相机是设定好的，固定的，虚拟出来的，也就是视图变换本质上只是在对模型进行变换，因此模型变换与视图变换常被一起称为模型视图变换。</p></li><li><p>使用数学表示视图变换：</p><p>定义 <spanclass="math inline">\(M_{view}=R_{view}T_{view}\)</span>，</p><ul><li><p>平移到原点 $ <spanclass="math display">\[\begin{gather*}T_{view}=\begin{pmatrix}1&amp;0&amp;0&amp;-x_e\\0&amp;1&amp;0&amp;-y_e\\0&amp;0&amp;1&amp;-z_e\end{pmatrix}\end{gather*}\]</span>$</p></li><li><p>旋转 <span class="math inline">\(g\)</span> 到 <spanclass="math inline">\(-Z\)</span>，<spanclass="math inline">\(t\)</span> 到 <spanclass="math inline">\(Y\)</span>，<span class="math inline">\((g\timest)\)</span> 到 <spanclass="math inline">\(X\)</span>，对此我们可以求逆变换：</p><p>旋转 <span class="math inline">\(X\)</span> 到 <spanclass="math inline">\((g\times t)\)</span>，<spanclass="math inline">\(Y\)</span> 到 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(Z\)</span>到 <span class="math inline">\(-g\)</span> ，可得： <spanclass="math display">\[{R_{view} }^{-1}=\begin{bmatrix}  x_{\hat{g}\times\hat{t} } &amp; x_t &amp; x_{-g} &amp; 0 \\  y_{\hat{g}\times\hat{t} } &amp; y_t &amp; y_{-g} &amp; 0 \\  z_{\hat{g}\times\hat{t} } &amp; z_t &amp; z_{-g} &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> 由于旋转的变换矩阵为正交矩阵，可得： <spanclass="math display">\[{R_{view}={ {(R_{view} }^{-1})} }^T=\begin{bmatrix}  x_{\hat{g}\times\hat{t} } &amp; y_{\hat{g}\times\hat{t} } &amp;z_{\hat{g}\times\hat{t} } &amp; 0 \\  x_t &amp; y_t &amp; z_t &amp; 0 \\  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p></li></ul></li></ul></li></ul><hr /><h3 id="projection-transformation">3. Projection Transformation</h3><ul><li><p><strong>什么是投影变换？</strong></p><p>投影变换分为正交投影与透视投影，二者的区别十分明显：</p></li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_10-02-59.png" style="zoom:33%;" /></p><ul><li><p><strong>正交投影</strong></p><p>正交投影是一种假设相机处于无限远的投影方式（忽略了模型的前后关系）。</p><ul><li><p>一种简单的正交投影方式：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_10-09-12.png" style="zoom:33%;" /></p><ul><li><p>固定相机；</p></li><li><p>丢掉 Z 轴；</p></li><li><p>将模型平移与缩放，使其全部位于 <spanclass="math inline">\([-1,1]^2\)</span> 的矩形范围内。</p></li></ul></li><li><p>常用的正交投影的方式：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_10-18-20.png" style="zoom:33%;" /></p><p>定义一个立方体 <spanclass="math inline">\([l,r]\times[b,t]\times[f,n]\)</span>与一个标准立方体 <span class="math inline">\([-1,1]^3\)</span>，</p><ul><li>通过先平移后缩放的方式，将立方体投影到标准立方体中。</li></ul><p>使用数学表示投影，先将立方体的中心移动到原点，再将其缩放到标准立方体内：<span class="math display">\[M_{ortho}=\begin{bmatrix}    \frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}    1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\    0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\    0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\    0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p></li></ul></li><li><p><strong>透视投影</strong></p><p>透视投影可以达到近大远小的效果。</p><ul><li><p>透视投影的方式：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_10-35-45.png" style="zoom:33%;" /></p><ul><li><p>思路：将视锥“挤压”成一个立方体，再将立方体正交投影到标准立方体中；（<spanclass="math inline">\(M_{persp}\rightarrow M_{ortho}\)</span>）</p></li><li><p>对于“挤压”的过程，定义近远都平面不变，远平面中心点不变；</p></li><li><p>从侧面看：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_10-55-30.png" style="zoom:33%;" /></p><p>根据相似三角形的性质，可得 <span class="math display">\[\begin{gather*}y&#39;=\frac{n}{z}y \\x&#39;=\frac{n}{z}x\end{gather*}\]</span> 根据这点，可得投影变换后的坐标： <span class="math display">\[\begin{pmatrix}  x \\ y \\ z \\ 1\end{pmatrix}\Rightarrow\begin{pmatrix}  \frac{n}{z}x \\ \frac{n}{z}y \\ ? \\ 1\end{pmatrix}=\begin{pmatrix}  nx \\ ny \\ ? \\ z\end{pmatrix}\]</span> 再逆向求投影变换的变换矩阵，已知： <spanclass="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}\begin{pmatrix}  x \\ y \\ z \\1\end{pmatrix} =\begin{pmatrix}  nx \\ ny \\ ? \\ z\end{pmatrix}\]</span> 可求得： <span class="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}=\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  ? &amp; ? &amp; ? &amp; ? \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\]</span></p></li><li><p>因为近平面上的点不变，设变换一个位于近平面上的点 <spanclass="math inline">\(\begin{pmatrix}x&amp;y&amp;n&amp;1\end{pmatrix}^T\)</span>，可得该点被“压缩”后坐标不变：<span class="math display">\[M^{(4\times4)}_{persp\rightarrow ortho}\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}=\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  ? &amp; ? &amp; ? &amp; ? \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}\Rightarrow\begin{pmatrix}  x \\ y \\ n \\ 1\end{pmatrix}=\begin{pmatrix}  nx \\ ny \\ n^2 \\ n\end{pmatrix}\]</span> 即 <span class="math inline">\(\begin{pmatrix} C &amp; D &amp;A &amp; B \end{pmatrix} \begin{pmatrix} x \\ y \\ n \\ 1 \end{pmatrix} =n^2\)</span> , 由于 x , y 与 n 无关，因此可以确定 C = D = 0 ，但无法确认A 与 B 的值。</p><p>由 <span class="math inline">\(\begin{pmatrix} 0 &amp; 0 &amp; A&amp; B \end{pmatrix} \begin{pmatrix} x \\ y \\ n \\ 1 \end{pmatrix} =n^2\)</span> ，可得 <spanclass="math inline">\(An+B=n^2\)</span>；</p></li><li><p>又因为远平面上的中心点不变，设远平面上中心点为 <spanclass="math inline">\(\begin{pmatrix}0&amp;0&amp;f&amp;1\end{pmatrix}^T\)</span>，同理可得：<span class="math display">\[\begin{pmatrix}      0 \\ 0 \\ f \\ 1  \end{pmatrix}  \Rightarrow  \begin{pmatrix}      0 \\ 0 \\ f \\ 1  \end{pmatrix}  =  \begin{pmatrix}      0 \\ 0 \\ f^2 \\ f  \end{pmatrix}  \Rightarrow  Af+B=f^2\]</span> 联立： <span class="math display">\[\begin{gather*}An+B=n^2\\Af+B=f^2\end{gather*}\]</span> 可解得： <span class="math display">\[\begin{gather*}A=n+f\\B=-nf\end{gather*}\]</span></p></li><li><p>最后可得，投影变换矩阵为： <span class="math display">\[\begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; n &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; n+f &amp; -nf \\  0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}\]</span></p></li></ul></li></ul></li><li><p><strong>如何定义一个视锥？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_15-02-47.png" style="zoom:33%;" /></p><ul><li><p>定义视锥的长宽比（aspect）与垂直可视角度（fovY）；</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-28_15-14-30.png" style="zoom:33%;" /></p></li><li><p>如何将 aspect 与 fovY 转换成 l, r, b, t ？ <spanclass="math display">\[\begin{gather*}\tan{\frac{fovY}{2} }=\frac{t}{\lvert n \rvert} \\aspect = \frac{r}{t}\end{gather*}\]</span></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>MVP变换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture03 Transformation</title>
    <link href="/2023/11/25/Games101-Lecture-03-Transformation/"/>
    <url>/2023/11/25/Games101-Lecture-03-Transformation/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/音姫01-small.png" /></p><h1 id="mvp-transformation">MVP Transformation</h1><h3 id="mvp-transformation-1">1. MVP Transformation</h3><ul><li><p><strong>什么是MVP变换？</strong></p><p>Model Transfors + View Transfors + Projection Transfors</p></li></ul><hr /><h3 id="d-model-transformations">2. 2D model transformations</h3><ul><li><p><strong>使用矩阵表示线性变换</strong></p><ul><li><p>缩放</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-25_18-12-06.png" alt="Snipaste_2023-11-25_18-12-06" style="zoom: 33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    s &amp; 0 \\    0 &amp; s\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>缩放（非对称）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231125181622307.png" style="zoom:33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    s_x &amp; 0 \\    0 &amp; s_y\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>镜像（反射）</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231125181820508.png" style="zoom:33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    -1 &amp; 0 \\    0 &amp; 1\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>切变</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231125182005285.png" style="zoom:33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    1 &amp; a \\    0 &amp; 1\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span></p></li><li><p>旋转</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231125190114296.png" style="zoom:33%;" /><span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    \cos\theta &amp; -\sin\theta \\    \sin\theta &amp; \cos\theta\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}\]</span> 当旋转 <span class="math inline">\(-\theta\)</span>角度时，容易发现： <span class="math display">\[\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=R_{-45}\cdot\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}=\begin{bmatrix}    \cos\theta &amp; \sin\theta \\    -\sin\theta &amp; \cos\theta\end{bmatrix}\begin{bmatrix}    x \\    y\end{bmatrix}={R_{45}}^T\cdot\begin{bmatrix}    x&#39; \\    y&#39;\end{bmatrix}\]</span> 又因 $ R_{-45}={R_{45}}^{-1}$,</p><p>因此 $ R_{-45}={R_{45}}<sup>{-1}={R_{45}}</sup>T$ ,该变换矩阵为正交矩阵。</p></li></ul></li></ul><hr /><h3 id="homogeneous-coordinates">3. Homogeneous coordinates</h3><ul><li><p><strong>为什么要引入齐次坐标？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231125193639426.png" style="zoom:33%;" /></p><p>这是一个简单的平移操作 ，我们知道移动后的图像各点坐标为： <spanclass="math display">\[\begin{gather*}  x&#39;=x+t_x \\  y&#39;=y+t_y\end{gather*}\]</span>但在将其写成矩阵的表示方式时就会发现，不能将其像其他线性变换一样表示出来：<span class="math display">\[\begin{bmatrix}  x&#39; \\  y&#39;\end{bmatrix}=\begin{bmatrix}  a &amp; -b \\  c &amp; d\end{bmatrix}\begin{bmatrix}  x \\  y\end{bmatrix}+\begin{bmatrix}  t_x \\  t_y\end{bmatrix}\]</span>那么有没有一种办法可以<strong>将缩放、旋转等线性变换与平移等非线性变换用一种简单的变换表示</strong>呢？</p><p>为了解决这个问题，我们引入了齐次坐标。</p></li><li><p><strong>什么是齐次坐标？</strong></p><p>在原本坐标的基础上添加一个维度：</p><ul><li>2D的点 <span class="math inline">\(=(x,y,1)^T\)</span></li><li>2D向量 <span class="math inline">\(=(x,y,0)^T\)</span></li></ul><p>因为向量在空间中的位置不同并不会对向量的值产生任何变化，因此向量的新的一维值为0。</p><p><strong>新增的维度的值使得齐次坐标的运算结果依旧满足以下等式</strong></p><ul><li><p><span class="math inline">\(vector + vector =vector\)</span></p></li><li><p><span class="math inline">\(point - point =vector\)</span></p></li><li><p><span class="math inline">\(point + vector =point\)</span></p></li></ul></li><li><p><strong>齐次坐标的扩充定义</strong></p><ul><li><p>在齐次坐标中，当 <span class="math inline">\(w\neq0\)</span>时，<span class="math inline">\(\begin{pmatrix} x \\ y \\ w\end{pmatrix}\)</span> 表示一个坐标为 <spanclass="math inline">\(\begin{pmatrix} x/w \\ y/w \\ 1\end{pmatrix}\)</span> 的二维的点。</p><p>则 <span class="math inline">\(point + point\)</span>的值为两个点的中点。</p></li></ul></li><li><p><strong>使用齐次坐标表示变换</strong></p><ul><li><p>平移 <span class="math display">\[\begin{pmatrix}    x&#39; \\    y&#39; \\    1\end{pmatrix} =\begin{pmatrix}    a &amp; b &amp; t_x \\    c &amp; d &amp; t_y \\    0 &amp; 0 &amp; 1\end{pmatrix}\begin{pmatrix}    x \\    y \\    1\end{pmatrix}\]</span> 通过改变 <span class="math inline">\(a、b、c、d\)</span>的值，可以做到表示线性变换，例如：</p></li><li><p>旋转 <span class="math display">\[\begin{pmatrix}    x&#39; \\    y&#39; \\    1\end{pmatrix} =\begin{pmatrix}    \cos\theta &amp; -\sin\theta &amp; 0 \\    \sin\theta &amp; \cos\theta &amp; 0 \\    0 &amp; 0 &amp; 1\end{pmatrix}\begin{pmatrix}    x \\    y \\    1\end{pmatrix}\]</span></p></li></ul></li></ul><hr /><h3 id="composite-transformation">4. Composite Transformation</h3><ul><li><p><strong>表示变换的合成时遇到的问题？</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-26_15-12-28.png" alt="Snipaste_2023-11-26_15-12-28" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-26_15-13-26.png" alt="Snipaste_2023-11-26_15-13-26" style="zoom:33%;" /></p><p>由图可知，相同的变换在使用不同变换顺序的情况下，得到的结果并不相同，即：<span class="math display">\[R_{45}\cdot T_{(1,0)} \neq T_{(1,0)}\cdot R_{45}\]</span>所以，在合成多个变换时，应该注意计算的顺序，顺序为<strong>从向量的左侧最近的变换矩阵开始运算</strong>。</p><p>例如，进行先旋转45度后向右平移 <span class="math inline">\(1\)</span>个单位距离应表示为： <span class="math display">\[T_{(1,0)}\cdot R_{45} \cdot\begin{bmatrix}  x \\  y \\  1\end{bmatrix}\]</span></p><p>另外，当平移与线性变换表示为同一个矩阵，计算时先进性线性变换，再进行平移变换。</p></li><li><p><strong>合成变换的推广</strong></p><p>对向量 <span class="math inline">\(\overrightarrow{S}\)</span>应用n个变换 <spanclass="math inline">\(A_1,A_2,A_3,...,A_n\)</span>，可以表示为： <spanclass="math display">\[A_n ...A_2\cdot A_1\cdot\overrightarrow{S}\]</span>虽然矩阵的乘法不满足交换律，但满足结合律。即我们可以先将n个变换 <spanclass="math inline">\(A_1,A_2,A_3,...,A_n\)</span>相乘得到一个复杂的矩阵，这个矩阵可以表示一种十分复杂的变换。</p></li><li><p><strong>变换的分解</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/Snipaste_2023-11-27_08-18-45.png" alt="Snipaste_2023-11-27_08-18-45" style="zoom:38%;" /></p><p>有些变换可能是不常规的，无法用简单的变换进行转换。对此，我们需要对变换进行分解，例如将以上图形绕<span class="math inline">\(c\)</span> 点旋转，该变换可以分解为：</p><ul><li>将图形平移 <span class="math inline">\(-c\)</span></li><li>旋转图形</li><li>将图形平移 <span class="math inline">\(c\)</span></li></ul><p>即 <span class="math inline">\(T(c)R(\alpha)T(-c)\)</span></p></li></ul><hr /><h3 id="d-transformation">5. 3D Transformation</h3><ul><li><p><strong>三维中的齐次坐标</strong></p><p>同二维的齐次坐标，添加第四维：</p><ul><li>3D的点 $ =(x,y,z,1)$</li><li>3D向量 <span class="math inline">\(=(x,y,z,0)\)</span></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>MVP变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101 - Lecture02 Review of Linear Algebra</title>
    <link href="/2023/11/22/Games101-Lecture-02-Review-of-Linear-Algebra/"/>
    <url>/2023/11/22/Games101-Lecture-02-Review-of-Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/memo2586/Image-repo/master/鳳ちはや01-samll.png" /></p><h1 id="review-of-linear-algebra">Review of Linear Algebra</h1><h3 id="vector-addition">1. Vector Addition</h3><ul><li><strong>平行四边形法则与三角形法则</strong></li></ul><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231122225034808.png" alt="image-20231122225034808" style="zoom: 67%;" /></p><ul><li><p><strong>坐标系</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231122232540795.png" alt="image-20231122232540795" style="zoom:67%;" /></p></li></ul><p>​ 缺省时一般认为向量为列向量: <span class="math display">\[\mathbf{A}=\begin{pmatrix}    x \\    y\end{pmatrix}\tag1\]</span></p><p><span class="math display">\[\mathbf{A^T}=\begin{pmatrix}    x &amp; y\end{pmatrix} \tag2\]</span></p><p><span class="math display">\[\|\mathbf{A}\|=\sqrt{x^2+y^2} \tag3\]</span></p><hr /><h3 id="vector-multiplication-dot-product">2. Vector Multiplication (DotProduct)</h3><ul><li><p><strong>点乘的计算</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231122230307232.png" style="zoom:67%;" /></p><p><strong>向量点乘的结果是一个数。</strong></p></li></ul><p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\|\overrightarrow{a}\|\|\overrightarrow{b}\|\cos\theta\tag1\]</span></p><p><span class="math display">\[\cos\theta=\frac{\overrightarrow{a}\cdot\overrightarrow{b}}{\|\overrightarrow{a}\|\|\overrightarrow{b}\|}\tag2\]</span></p><p>​ 当两个向量都是单位向量时（长度都为1）： <spanclass="math display">\[\cos\theta=\hat{a}\cdot\hat{b}\]</span></p><ul><li><p><strong>点乘的性质</strong></p><ul><li><p><spanclass="math inline">\(\overrightarrow{a}\cdot\overrightarrow{b}=\overrightarrow{b}\cdot\overrightarrow{a}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\cdot(\overrightarrow{b}+\overrightarrow{c})=\overrightarrow{a}\cdot\overrightarrow{b}+\overrightarrow{a}\cdot\overrightarrow{c}\)</span></p></li><li><p><spanclass="math inline">\((k\overrightarrow{a})\cdot=\overrightarrow{a}\cdot(k\overrightarrow{a})=k(\overrightarrow{a}\cdot\overrightarrow{b})\)</span></p></li></ul></li><li><p><strong>笛卡尔坐标系下的点乘运算</strong></p></li></ul><p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\begin{pmatrix}    x_a \\    y_a\end{pmatrix}\cdot\begin{pmatrix}    x_b \\    y_b\end{pmatrix}=x_ax_b+y_ay_b\]</span> ​<strong>点乘最大的作用在于找到两个向量之间的夹角大小。</strong></p><ul><li><strong>通过点乘求向量在另一个向量上的投影</strong></li></ul><p>​点乘的另一个作用是用于<strong>找到一个向量在另一个向量上的投影</strong>：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231123172442079.png" style="zoom:67%;" /></p><p>​ <span class="math inline">\(\overrightarrow{b}_\bot\)</span> 是<span class="math inline">\(\overrightarrow{b}\)</span> 在 <spanclass="math inline">\(\overrightarrow{a}\)</span> 方向上的投影，因此：<span class="math display">\[\overrightarrow{b_\bot}=k\hat{a}\]</span> ​ 其中 k 的大小为： <span class="math display">\[k=\|\overrightarrow{b_\bot}\|=\|\overrightarrow{b}\|\cos{\theta}\]</span> ​ 利用点乘计算出 <spanclass="math inline">\(\cos{\theta}\)</span> 后便可以求出 <spanclass="math inline">\(\overrightarrow{b_\bot}\)</span> 。</p><p><strong>已知向量在另一个向量上的投影后，可以对该向量任意地进行平行与垂直的分解</strong>：</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231123184130756.png" style="zoom:67%;" /></p><ul><li><p><strong>通过点乘计算向量间的位置关系</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231123195107566.png" style="zoom:67%;" /></p></li></ul><p>以向量 <span class="math inline">\(\overrightarrow{a}\)</span>的方向为基准定义前与后，当一个向量与向量 <spanclass="math inline">\(\overrightarrow{a}\)</span>的点乘大于0时，称该向量位于前方。反之，当一个向量与向量 <spanclass="math inline">\(\overrightarrow{a}\)</span>的点乘小于0时，称该向量位于后方。</p><p><strong>两个向量的单位向量的点乘越接近1，则这两个向量在方向上越接近。</strong></p><hr /><h3 id="vector-multiplication-cross-product">3 Vector Multiplication(Cross Product)</h3><ul><li><p><strong>叉乘的计算</strong></p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231123200453651.png" style="zoom:67%;" /></p></li></ul><p>​<strong>两个向量叉乘的计算结果是一个垂直于这两个向量所在平面的向量。</strong><span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=-\overrightarrow{b}\times\overrightarrow{a}\tag1\]</span></p><p><span class="math display">\[\|\overrightarrow{a}\times\overrightarrow{b}\|=\|\overrightarrow{a}\|\|\overrightarrow{b}\|\sin{\phi}\tag2\]</span></p><p>​利用叉乘可以建立一个在三维空间中的直角坐标系（使用右手螺旋定则可以确定运算结果的向量的方向）：<span class="math display">\[\overrightarrow{x}\times\overrightarrow{y}=+\overrightarrow{z} \tag1\]</span></p><p><span class="math display">\[\overrightarrow{y}\times\overrightarrow{x}=-\overrightarrow{z} \tag2\]</span></p><p><span class="math display">\[\overrightarrow{y}\times\overrightarrow{z}=+\overrightarrow{x} \tag3\]</span></p><p><span class="math display">\[......\]</span></p><ul><li><p><strong>叉乘的性质</strong></p><ul><li><p><spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{b}=-\overrightarrow{b}\times\overrightarrow{a}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{a}=\overrightarrow{0}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times(\overrightarrow{b}+\overrightarrow{c})=\overrightarrow{a}\times\overrightarrow{b}+\overrightarrow{a}\times\overrightarrow{c}\)</span></p></li><li><p><spanclass="math inline">\(\overrightarrow{a}\times(k\overrightarrow{b})=k(\overrightarrow{a}\times\overrightarrow{b})\)</span></p></li></ul></li><li><p><strong>笛卡尔坐标系下的叉乘运算</strong> <spanclass="math display">\[\overrightarrow{a}\times\overrightarrow{b}=\begin{pmatrix}  y_az_b-y_bz_a \\  z_ax_b-x_az_b \\  x_ay_b-y_ax_b\end{pmatrix}\]</span></p></li><li><p><strong>叉乘的作用</strong></p></li></ul><p>​ <strong>判断某一点是否在图形的内部</strong>。 ​</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231124152224648.png" style="zoom:33%;" /></p><p>​ 如图，<spanclass="math inline">\(\overrightarrow{a}\times\overrightarrow{b}\)</span>的值为正，可得 <span class="math inline">\(\overrightarrow{b}\)</span>在 <span class="math inline">\(\overrightarrow{a}\)</span>的左侧，反之同理，可以判断两个向量的相对左右位置。</p><p><img src="https://raw.githubusercontent.com/memo2586/Image-repo/master/image-20231124152552096.png" style="zoom: 33%;" /></p><p>​要判断点P是否在顺序的，首尾相接的三个向量组成的三角形内部，则只需要计算<spanclass="math inline">\(\overrightarrow{AB}\times\overrightarrow{AP}\)</span>、<spanclass="math inline">\(\overrightarrow{BC}\times\overrightarrow{BP}\)</span>、<spanclass="math inline">\(\overrightarrow{CA}\times\overrightarrow{CP}\)</span>的值是否都为正值或负值，即点P都在三个向量的左侧或右侧。</p><hr /><h3 id="orthonormal-bases-and-coordinate-frames">4. Orthonormal basesand coordinate frames</h3><ul><li><p>建立一个直角坐标系，定义： <span class="math display">\[\|\overrightarrow{u}\|=\|\overrightarrow{v}\|=\|\overrightarrow{w}\|=1\tag1\]</span></p><p><span class="math display">\[\overrightarrow{u}\cdot\overrightarrow{v}=\overrightarrow{v}\cdot\overrightarrow{w}=\overrightarrow{u}\cdot\overrightarrow{w}=0\tag2\]</span></p><p><span class="math display">\[\overrightarrow{w}=\overrightarrow{u}\times\overrightarrow{v} \tag3\]</span></p><p>可以使用投影将任意向量分解，如： <span class="math display">\[\overrightarrow{p}=(\overrightarrow{p}\cdot\overrightarrow{u})\overrightarrow{v}+(\overrightarrow{p}\cdot\overrightarrow{v})\overrightarrow{v}+(\overrightarrow{p}\cdot\overrightarrow{w})\overrightarrow{w}\]</span></p></li></ul><hr /><h3 id="matrix">5. Matrix</h3><ul><li><p><strong>矩阵乘法</strong></p><p>设 <span class="math inline">\(A\times B=C\)</span> ，则有 <spanclass="math inline">\(C_{ij}=A_i\cdot B_j\)</span></p></li><li><p><strong>矩阵乘法的性质</strong></p><ul><li>不满足任何交换律</li><li><span class="math inline">\((AB)C = A(BC)\)</span></li><li><span class="math inline">\(A(B+C)=AB+AC\)</span></li><li><span class="math inline">\((A+B)C=AC+BC\)</span></li><li><span class="math inline">\((AB)^\intercal=B^\intercalA^\intercal\)</span></li></ul></li><li><p><strong>矩阵的逆</strong></p><ul><li>单位矩阵是只在对角线上有非零的元素，定义以下单位矩阵：</li></ul><p><span class="math display">\[I_{2\times2}=\begin{pmatrix}  1 &amp; 0 \\  0 &amp; 1 \\\end{pmatrix}\]</span></p><p>​ 则有： <span class="math display">\[AA^{-1}=A^{-1}A=I\]</span></p><ul><li>矩阵的逆的性质： <span class="math display">\[(AB)^{-1}=B^{-1}A^{-1}\]</span></li></ul></li><li><p><strong>将向量的乘积写成矩阵形式</strong></p><ul><li><p>点乘： <span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=\overrightarrow{a}^T\overrightarrow{b}=\begin{pmatrix}x_a &amp; y_a &amp; z_a\end{pmatrix}\begin{pmatrix}x_a \\y_a \\z_a\end{pmatrix}=(x_ax_b+y_ay_b+z_az_b)\]</span></p></li><li><p>叉乘： <span class="math display">\[\overrightarrow{a}\times\overrightarrow{b}=A^*b=\begin{pmatrix}    0 &amp; -z_a &amp; y_a \\    z_a &amp; 0 &amp; -x_a \\    -y_a &amp; x_a &amp; 0\end{pmatrix}\begin{pmatrix}    x_b \\    y_b \\    z_b\end{pmatrix}\]</span></p><pre><code class="hljs">​   </code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
      <tag>计算机图形学</tag>
      
      <tag>笔记</tag>
      
      <tag>数学基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于opencv与pyautogui编写的天翼校园掉线自动重连脚本</title>
    <link href="/2023/10/21/%E5%9F%BA%E4%BA%8Eopencv%E4%B8%8Epyautogui%E7%BC%96%E5%86%99%E7%9A%84%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E6%8E%89%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/10/21/%E5%9F%BA%E4%BA%8Eopencv%E4%B8%8Epyautogui%E7%BC%96%E5%86%99%E7%9A%84%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E6%8E%89%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>因为下载机上的天翼校园隔三岔五就掉线，所以有了这个程序...</p><p>图形化界面需要用到pyqt5和qt-material</p><p>不会写python，乱写，程序倒是还挺稳定，能用 orz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pyautogui<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageGrab<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtWidgets<br><span class="hljs-keyword">from</span> qt_material <span class="hljs-keyword">import</span> apply_stylesheet<br><span class="hljs-keyword">from</span> main_window <span class="hljs-keyword">import</span> Ui_Form<br><br><span class="hljs-comment"># 读取目标图片</span><br>image_message = cv2.imread(<span class="hljs-string">&#x27;message.png&#x27;</span>)<br>image_login = cv2.imread(<span class="hljs-string">&#x27;login.png&#x27;</span>)<br>h1, w1, _ = image_message.shape<br>h2, w2, _ = image_login.shape<br>threshold = <span class="hljs-number">0.6</span><br>run_flag = <span class="hljs-literal">False</span><br>labelEdit = <span class="hljs-literal">None</span><br>errorNum = <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 子线程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">start_threading</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.image = <span class="hljs-literal">None</span><br>        self.run()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, image</span>):<br>        self.image = image<br>        screenshot = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 获取屏幕截图</span><br>        <span class="hljs-comment"># screenshot = ImageGrab.grab()</span><br>        <span class="hljs-keyword">try</span>:<br>            screenshot = ImageGrab.grab()<br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> OSE:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> other_err:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] <span class="hljs-subst">&#123;other_err&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-comment"># screenshot.save(f&#x27;src/&#123;self.get_time()&#125;.png&#x27;)</span><br>        <span class="hljs-keyword">if</span> screenshot <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        screenshot = np.array(screenshot)<br>        <span class="hljs-comment"># 在屏幕截图上搜索目标图片</span><br>        result = cv2.matchTemplate(screenshot, image, cv2.TM_CCOEFF_NORMED)<br>        loc = np.where(result &gt;= threshold)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(loc[<span class="hljs-number">0</span>]) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(loc[<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [loc[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], loc[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_time</span>(<span class="hljs-params">self</span>):<br>        now = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H-%M-%S&#x27;</span>, time.localtime())<br>        <span class="hljs-keyword">return</span> now<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>                <span class="hljs-keyword">global</span> run_flag, errorNum<br><br>                <span class="hljs-keyword">while</span> run_flag:<br>                    now = self.get_time()<br>                    set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nchecking...\nerrorNum: <span class="hljs-subst">&#123;errorNum&#125;</span>&#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\n checking...&#x27;</span>)<br>                    x, y = self.find(image_message)<br><br>                    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                        <span class="hljs-comment"># print(f&#x27; running normally!&#x27;)</span><br>                        <span class="hljs-keyword">pass</span><br>                    <span class="hljs-keyword">elif</span> x &lt; <span class="hljs-number">0</span>:<br>                        set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>] 截图失败！&#x27;</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[&#123;self.get_time()&#125;] screen grab failed&#x27;)</span><br>                    <span class="hljs-keyword">else</span>:<br>                        errorNum = errorNum + <span class="hljs-number">1</span><br>                        now = self.get_time()<br>                        set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\n Error! Enable automated scripts...&#x27;</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[&#123;now&#125;]\n Error! Enable automated scripts...&#x27;)</span><br>                        time.sleep(<span class="hljs-number">1</span>)<br>                        <span class="hljs-comment"># print(f&#x27;[message_pos]: &#123;x&#125;,&#123;y&#125;&#x27;)</span><br>                        pyautogui.click(x + w1 // <span class="hljs-number">2</span>, y + h1 // <span class="hljs-number">2</span>)<br>                        time.sleep(<span class="hljs-number">1</span>)<br><br>                        <span class="hljs-keyword">while</span> run_flag:<br>                            x, y = self.find(image_login)<br>                            <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                                now = self.get_time()<br>                                set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nError!\ncant not find login button!\ntrying again...&#x27;</span>)<br>                                <span class="hljs-comment"># print(&quot;Error! can&#x27;t not find login! trying again...&quot;)</span><br>                                time.sleep(<span class="hljs-number">3</span>)<br>                            <span class="hljs-keyword">else</span>:<br>                                time.sleep(<span class="hljs-number">1</span>)<br>                                <span class="hljs-comment"># print(f&#x27;[login_pos]: &#123;x&#125;,&#123;y&#125;&#x27;)</span><br>                                pyautogui.click(x + w2 // <span class="hljs-number">2</span>, y + h2 // <span class="hljs-number">2</span>)<br>                                now = self.get_time()<br>                                set_label_text(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;now&#125;</span>]\nSuccess!\nAutomation script completed.&#x27;</span>)<br>                                <span class="hljs-comment"># print(&quot;Success! Automation script completed.&quot;)</span><br>                                <span class="hljs-keyword">break</span><br>                    time.sleep(<span class="hljs-number">3</span>)<br>                time.sleep(<span class="hljs-number">3</span>)<br><br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> OSE:<br>            set_label_text(<span class="hljs-string">f&#x27;系统错误: <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;self.get_time()&#125;</span>]系统错误: <span class="hljs-subst">&#123;OSE&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> other_error:<br>            now = self.get_time()<br>            set_label_text(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;now&#125;</span>未知错误\n：<span class="hljs-subst">&#123;other_error&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;now&#125;</span>未知错误\n：<span class="hljs-subst">&#123;other_error&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;STOP&quot;</span>)<br><br><br><span class="hljs-comment"># 主窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span>(QtWidgets.QWidget, Ui_Form):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MainWindow, self).__init__()<br>        self.setupUi(self)<br>        <span class="hljs-keyword">global</span> labelEdit<br>        labelEdit = self.label<br>        apply_stylesheet(app, theme=<span class="hljs-string">&#x27;dark_teal.xml&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click_start_button</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> run_flag<br>        <span class="hljs-keyword">if</span> run_flag:<br>            run_flag = <span class="hljs-literal">False</span><br>            self.startButton.setText(<span class="hljs-string">&quot;RESTART&quot;</span>)<br>            self.label.setText(<span class="hljs-string">&quot;Click button to start.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            run_flag = <span class="hljs-literal">True</span><br>            self.startButton.setText(<span class="hljs-string">&quot;STOP&quot;</span>)<br>            self.label.setText(<span class="hljs-string">&quot;Running...\n&quot;</span>)<br><br><br>thread = threading.Thread(target=start_threading)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_label_text</span>(<span class="hljs-params">message</span>):<br>    labelEdit.setText(message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QtWidgets.QApplication(sys.argv)<br><br>    <span class="hljs-comment"># 开启检测子线程</span><br>    thread.daemon = <span class="hljs-literal">True</span><br>    thread.start()<br><br>    test_ui = MainWindow()<br>    test_ui.show()<br><br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main_window.py</span><br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtCore, QtGui, QtWidgets<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ui_Form</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setupUi</span>(<span class="hljs-params">self, Form</span>):<br>        Form.setObjectName(<span class="hljs-string">&quot;AutoLogin&quot;</span>)<br>        Form.resize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>)<br>        Form.setMinimumSize(QtCore.QSize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>))<br>        Form.setMaximumSize(QtCore.QSize(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>))<br>        font = QtGui.QFont()<br>        font.setFamily(<span class="hljs-string">&quot;微软雅黑&quot;</span>)<br>        font.setPointSize(<span class="hljs-number">12</span>)<br>        Form.setFont(font)<br>        Form.setContextMenuPolicy(QtCore.Qt.NoContextMenu)<br>        self.verticalLayoutWidget = QtWidgets.QWidget(Form)<br>        self.verticalLayoutWidget.setGeometry(QtCore.QRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">311</span>, <span class="hljs-number">261</span>))<br>        self.verticalLayoutWidget.setObjectName(<span class="hljs-string">&quot;verticalLayoutWidget&quot;</span>)<br>        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)<br>        self.verticalLayout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        self.verticalLayout.setObjectName(<span class="hljs-string">&quot;verticalLayout&quot;</span>)<br>        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)<br>        self.label.setMinimumSize(QtCore.QSize(<span class="hljs-number">0</span>, <span class="hljs-number">180</span>))<br>        self.label.setAlignment(QtCore.Qt.AlignCenter)<br>        self.label.setObjectName(<span class="hljs-string">&quot;label&quot;</span>)<br>        self.verticalLayout.addWidget(self.label)<br>        spacerItem = QtWidgets.QSpacerItem(<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)<br>        self.verticalLayout.addItem(spacerItem)<br>        self.startButton = QtWidgets.QPushButton(self.verticalLayoutWidget)<br>        self.startButton.setMinimumSize(QtCore.QSize(<span class="hljs-number">130</span>, <span class="hljs-number">0</span>))<br>        self.startButton.setMaximumSize(QtCore.QSize(<span class="hljs-number">150</span>, <span class="hljs-number">16777215</span>))<br>        self.startButton.setObjectName(<span class="hljs-string">&quot;startButton&quot;</span>)<br>        self.verticalLayout.addWidget(self.startButton, <span class="hljs-number">0</span>, QtCore.Qt.AlignHCenter)<br>        spacerItem1 = QtWidgets.QSpacerItem(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)<br>        self.verticalLayout.addItem(spacerItem1)<br><br>        self.retranslateUi(Form)<br>        self.startButton.clicked.connect(Form.click_start_button) <span class="hljs-comment"># type: ignore</span><br>        QtCore.QMetaObject.connectSlotsByName(Form)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">retranslateUi</span>(<span class="hljs-params">self, Form</span>):<br>        _translate = QtCore.QCoreApplication.translate<br>        Form.setWindowTitle(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;AutoLogin&quot;</span>))<br>        self.label.setText(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;Click to Start.&quot;</span>))<br>        self.startButton.setText(_translate(<span class="hljs-string">&quot;Form&quot;</span>, <span class="hljs-string">&quot;Start&quot;</span>))<br></code></pre></td></tr></table></figure><p>用到的两张图片分别是天翼校园掉线时的提示窗口上的确认按钮和主程序窗口上的登录按钮，截个图就行。</p>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用WinCDEmu的galgame光盘映像的自动挂载与卸载脚本</title>
    <link href="/2023/10/11/%E4%BD%BF%E7%94%A8WinCDEmu%E7%9A%84galgame%E5%85%89%E7%9B%98%E6%98%A0%E5%83%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/10/11/%E4%BD%BF%E7%94%A8WinCDEmu%E7%9A%84galgame%E5%85%89%E7%9B%98%E6%98%A0%E5%83%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>挺久之前写的一个简单脚本，偶尔还能用上。</p><p>放在游戏目录下，修改变量值。脚本运行后能做到自动挂载光盘和启动游戏程序，检查到游戏进程关闭时自动卸载光盘。</p><p>光盘的挂载用的是<ahref="https://github.com/sysprogs/WinCDEmu">WinCDEmu</a>，把程序batchmnt.exe添加到用户环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><br>::镜像文件路径<br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;cur_path=%CD%&quot;</span><br>::修改这里<br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;iso_filename=DC3WY&quot;</span><br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;gamename=DC3WY&quot;</span><br><br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;iso_filepath=%cur_path%\%iso_filename%.ISO&quot;</span><br><br>::挂载<br><span class="hljs-built_in">echo</span> MOUNT %iso_filepath% !<br>batchmnt <span class="hljs-string">&quot;%iso_filepath%&quot;</span><br>::等待挂载<br>choice /t 1 /d y /n &gt;nul<br><br>::启动游戏<br>%gamename%.EXE<br><br>:start<br>choice /t 2 /d y /n &gt;nul<br>tasklist|find /i <span class="hljs-string">&quot;%gamename%.EXE&quot;</span><br><span class="hljs-keyword">if</span> %errorlevel% NEQ 0 ( <br>                <span class="hljs-built_in">echo</span> The %gamename% closes !<br>    goto end<br>)<br>goto start  （循环）<br><br>:end<br>batchmnt /unmount <span class="hljs-string">&quot;%iso_filepath%&quot;</span><br><br><span class="hljs-built_in">echo</span> UNMOUNTED %iso_filepath% !<br><br>choice /t 2 /d y /n &gt;nul<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
